# Generator Output

1. Comment Block indicating this file is autogenerated

```c# 
//------------------------------------------------------------------------------
// <auto-generated>
//		This code was generated from a template.
//		Manual changes to this file may cause unexpected behavior in your application.
//		Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

```

2. Using statements which are controlled by `AllowedNamespaces` and `ExcludedNamespaces`

```c#

using TestWebApp.Contracts;
using AspNetCore.Client;
using AspNetCore.Client.Authorization;
using AspNetCore.Client.Exceptions;
using AspNetCore.Client.Http;
using AspNetCore.Client.RequestModifiers;
using AspNetCore.Client.Serializers;
using Flurl.Http;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Linq;
using System.Collections.Generic;
using System.Net.Http;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;

```

3. Namespace which is controlled by `ClientNamespace`


```c#
namespace TestWebApp.Clients
```

4. Installer class, the name is controlled by `ClientInterfaceName`

```c#

public static class TestWebAppClientInstaller
{
	public static IServiceCollection InstallClients(this IServiceCollection services, Action<ClientConfiguration> configure)
}

```

5. Flurl client wrapper, name controlled by `ClientInterfaceName`. This class is injected into every client

```c#
public class TestWebAppClient
{
	public TestWebAppClient(HttpClient client, string baseAddress, TimeSpan timeout)
}
```

6. Base client interface, implemented by each client, can be used for reflection

```c#
public interface ITestWebAppClient : IClient
```

7. Generated Client Interface
   - The generator makes 2 types of methods for each endpoint
   - A raw one which returns a `HttpResponseMessage`
   - A methoid that is tailored to the attributes.
   - Both sync and async methods are generated
   - Task used depends on `UseValueTask`

```c#
public interface IValuesClient : ITestWebAppClient
{
		
	IEnumerable<string> Get(Action<HttpResponseMessage> ResponseCallback = null, 
		CancellationToken cancellationToken = default(CancellationToken));

		
	HttpResponseMessage GetRaw(CancellationToken cancellationToken = default(CancellationToken));

		
	ValueTask<IEnumerable<string>> GetAsync(Action<HttpResponseMessage> ResponseCallback = null, 
		CancellationToken cancellationToken = default(CancellationToken));

		
	ValueTask<HttpResponseMessage> GetRawAsync(CancellationToken cancellationToken = default(CancellationToken));
}
```

8. Client implementation

```c#

public class ValuesClient : IValuesClient
{
	public ValuesClient(TestWebAppClient client, IHttpOverride httpOverride, IHttpSerializer serializer, IRequestModifier modifier)
}


```

9. Client Method implementation

- If the endpoint returns a type, it will be used as the return type.
- But if it returns a variant of IActionResult or ActionResult, it will be void
- The controller and action local variables are due to using `[controller]` and `[action]` in the route.

```c#

public IEnumerable<string> Get(	Action<HttpResponseMessage> ResponseCallback = null, 
			CancellationToken cancellationToken = default(CancellationToken))
{

			
	var controller = "Values";


	string url = $@"api/{controller}";
	HttpResponseMessage response = null;
	response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
	if(response == null)
	{
		response = Client.ClientWrapper
		.Request(url)
		.WithRequestModifiers(Modifier)
		.AllowAnyHttpStatus()
		.WithTimeout(Client.Timeout)
		.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
		HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
	}

	if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
	{
		throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
	}
	ResponseCallback?.Invoke(response);
			
	if(response.IsSuccessStatusCode)
	{
		return Serializer.Deserialize<IEnumerable<string>>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
	}
	else
	{
		return default(IEnumerable<string>);
	}

}

```