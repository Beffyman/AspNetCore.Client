//------------------------------------------------------------------------------
// <auto-generated>
//		This code was generated from a template.
//		Manual changes to this file may cause unexpected behavior in your application.
//		Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using TestWebApp.Contracts;
using AspNetCore.Client;
using AspNetCore.Client.Authorization;
using AspNetCore.Client.Exceptions;
using AspNetCore.Client.Http;
using AspNetCore.Client.RequestModifiers;
using AspNetCore.Client.Serializers;
using Flurl.Http;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Linq;
using System.Collections.Generic;
using System.Net;
using System.Net.Http;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;

namespace TestWebApp.Clients
{

#warning  File C:\Git_Github\AspNetCore.Client\test\TestWebApp\Controllers\ErrorController.cs is misconfigured for generation :: Controller must have a route to be valid for generation.


	public static class TestWebAppClientInstaller
	{
		/// <summary>
		/// Register the autogenerated clients into the container with a lifecycle of scoped.
		/// </summary>
		/// <param name="services"></param>
		/// <param name="configure">Overrides for client configuration</param>
		/// <returns></returns>
		public static IServiceCollection InstallClients(this IServiceCollection services, Action<ClientConfiguration> configure)
		{
			var configuration = new ClientConfiguration();

			configuration.RegisterClientWrapperCreator(TestWebAppClientWrapper.Create);
			configuration.UseClientWrapper<ITestWebAppClientWrapper, TestWebAppClientWrapper>((provider) => new TestWebAppClientWrapper(provider.GetService<HttpClient>(), configuration.GetSettings()));

			configure?.Invoke(configuration);

			services.AddScoped<ITestWebAppClientRepository,TestWebAppClientRepository>();
			services.AddScoped<ITestWebAppClientV1Repository,TestWebAppClientV1Repository>();
			services.AddScoped<ITestWebAppClientV2Repository,TestWebAppClientV2Repository>();
			services.AddScoped<FancySuffix.INamespacedClient, FancySuffix.NamespacedClient>();
			services.AddScoped<IValuesClient, ValuesClient>();
			services.AddScoped<V1.ITestClient, V1.TestClient>();
			services.AddScoped<V2.ITestClient, V2.TestClient>();

			return configuration.ApplyConfiguration(services);;
		}
	}




	public interface ITestWebAppClientWrapper : IClientWrapper { }

	public class TestWebAppClientWrapper :  ITestWebAppClientWrapper
	{
		public TimeSpan Timeout { get; internal set; }
		public FlurlClient ClientWrapper { get; internal set; }

		public TestWebAppClientWrapper(HttpClient client, ClientSettings settings)
		{
			if (!string.IsNullOrEmpty(settings.BaseAddress))
			{
				client.BaseAddress = new Uri(settings.BaseAddress);
			}
			ClientWrapper = new FlurlClient(client);
			Timeout = settings.Timeout;
		}

		public static ITestWebAppClientWrapper Create(HttpClient client, ClientSettings settings)
		{
			return new TestWebAppClientWrapper(client, settings);
		}
	}

	public interface ITestWebAppClient : IClient { }


	public interface ITestWebAppClientRepository
	{
		FancySuffix.INamespacedClient Namespaced { get; }
		IValuesClient Values { get; }
	}

	internal class TestWebAppClientRepository : ITestWebAppClientRepository
	{
		public FancySuffix.INamespacedClient Namespaced { get; private set;}
		public IValuesClient Values { get; private set;}

		public TestWebAppClientRepository
		(
			FancySuffix.INamespacedClient namespaced,
			IValuesClient values
		)
		{
			this.Namespaced = namespaced;
			this.Values = values;
		}
	}


	public interface ITestWebAppClientV1Repository
	{
		V1.ITestClient Test { get; }
	}

	internal class TestWebAppClientV1Repository : ITestWebAppClientV1Repository
	{
		public V1.ITestClient Test { get; private set;}

		public TestWebAppClientV1Repository
		(
			V1.ITestClient test
		)
		{
			this.Test = test;
		}
	}


	public interface ITestWebAppClientV2Repository
	{
		V2.ITestClient Test { get; }
	}

	internal class TestWebAppClientV2Repository : ITestWebAppClientV2Repository
	{
		public V2.ITestClient Test { get; private set;}

		public TestWebAppClientV2Repository
		(
			V2.ITestClient test
		)
		{
			this.Test = test;
		}
	}


}


namespace TestWebApp.Clients
{

namespace FancySuffix
{


	public interface INamespacedClient : ITestWebAppClient
	{
		
		void Test(Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		HttpResponseMessage TestRaw(TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		Task TestAsync(Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<HttpResponseMessage> TestRawAsync(TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

	}


	internal class NamespacedClient : INamespacedClient
	{
		public readonly ITestWebAppClientWrapper Client;
		public readonly IHttpOverride HttpOverride;
		public readonly IHttpSerializer Serializer;
		public readonly IRequestModifier Modifier;

		public NamespacedClient(ITestWebAppClientWrapper client, IHttpOverride httpOverride, IHttpSerializer serializer, IRequestModifier modifier)
		{
			Client = client;
			HttpOverride = httpOverride;
			Serializer = serializer;
			Modifier = modifier;
		}


		public void Test(Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			



			string url = $@"api/namespaced/test";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}


			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public HttpResponseMessage TestRaw(TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			



			string url = $@"api/namespaced/test";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}


		public async Task TestAsync(Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			



			string url = $@"api/namespaced/test";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}


			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public async ValueTask<HttpResponseMessage> TestRawAsync(TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			



			string url = $@"api/namespaced/test";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

	}
}





	public interface IValuesClient : ITestWebAppClient
	{
		
		IEnumerable<string> Get(int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		HttpResponseMessage GetRaw(int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<IEnumerable<string>> GetAsync(int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<HttpResponseMessage> GetRawAsync(int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		string Get(int id, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		HttpResponseMessage GetRaw(int id, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<string> GetAsync(int id, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<HttpResponseMessage> GetRawAsync(int id, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		void Post(string value, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		HttpResponseMessage PostRaw(string value, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		Task PostAsync(string value, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<HttpResponseMessage> PostRawAsync(string value, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		void Put(int id, 
			string value, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		HttpResponseMessage PutRaw(int id, 
			string value, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		Task PutAsync(int id, 
			string value, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<HttpResponseMessage> PutRawAsync(int id, 
			string value, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		void Delete(int id, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			SecurityHeader auth = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		HttpResponseMessage DeleteRaw(int id, 
			int ControllerHeader = 0, 
			SecurityHeader auth = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		Task DeleteAsync(int id, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			SecurityHeader auth = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<HttpResponseMessage> DeleteRawAsync(int id, 
			int ControllerHeader = 0, 
			SecurityHeader auth = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		void CancellationTestEndpoint(int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		HttpResponseMessage CancellationTestEndpointRaw(int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		Task CancellationTestEndpointAsync(int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<HttpResponseMessage> CancellationTestEndpointRawAsync(int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		string HeaderTestString(String SpecialValue1, 
			string SpecialValue2, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		HttpResponseMessage HeaderTestStringRaw(String SpecialValue1, 
			string SpecialValue2, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<string> HeaderTestStringAsync(String SpecialValue1, 
			string SpecialValue2, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<HttpResponseMessage> HeaderTestStringRawAsync(String SpecialValue1, 
			string SpecialValue2, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		int HeaderTestInt(int SpecialValue1, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		HttpResponseMessage HeaderTestIntRaw(int SpecialValue1, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<int> HeaderTestIntAsync(int SpecialValue1, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<HttpResponseMessage> HeaderTestIntRawAsync(int SpecialValue1, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		void FancyDtoReturn(int id, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<MyFancyDto> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		HttpResponseMessage FancyDtoReturnRaw(int id, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		Task FancyDtoReturnAsync(int id, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<MyFancyDto> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<HttpResponseMessage> FancyDtoReturnRawAsync(int id, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		void TaskReturn(MyFancyDto dto, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		HttpResponseMessage TaskReturnRaw(MyFancyDto dto, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		Task TaskReturnAsync(MyFancyDto dto, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<HttpResponseMessage> TaskReturnRawAsync(MyFancyDto dto, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		MyFancyDto DtoForDto(MyFancyDto dto, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		HttpResponseMessage DtoForDtoRaw(MyFancyDto dto, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<MyFancyDto> DtoForDtoAsync(MyFancyDto dto, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<HttpResponseMessage> DtoForDtoRawAsync(MyFancyDto dto, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		void GuidReturn(int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<Guid> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		HttpResponseMessage GuidReturnRaw(int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		Task GuidReturnAsync(int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<Guid> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<HttpResponseMessage> GuidReturnRawAsync(int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		void DateTimeReturns(int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<DateTime> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		HttpResponseMessage DateTimeReturnsRaw(int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		Task DateTimeReturnsAsync(int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<DateTime> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<HttpResponseMessage> DateTimeReturnsRawAsync(int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		void BoolReturns(int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<bool> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		HttpResponseMessage BoolReturnsRaw(int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		Task BoolReturnsAsync(int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<bool> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<HttpResponseMessage> BoolReturnsRawAsync(int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		void PostWithNoBody(Guid id, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		HttpResponseMessage PostWithNoBodyRaw(Guid id, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		Task PostWithNoBodyAsync(Guid id, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<HttpResponseMessage> PostWithNoBodyRawAsync(Guid id, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		void ComplexPost(Guid testId, 
			MyFancyDto dto, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<MyFancyDto> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		HttpResponseMessage ComplexPostRaw(Guid testId, 
			MyFancyDto dto, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		Task ComplexPostAsync(Guid testId, 
			MyFancyDto dto, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<MyFancyDto> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<HttpResponseMessage> ComplexPostRawAsync(Guid testId, 
			MyFancyDto dto, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		void PostWithSimpleBody(Guid id, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<Guid> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		HttpResponseMessage PostWithSimpleBodyRaw(Guid id, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		Task PostWithSimpleBodyAsync(Guid id, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<Guid> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<HttpResponseMessage> PostWithSimpleBodyRawAsync(Guid id, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		void EnumerableGet(IEnumerable<int> ids, 
			IEnumerable<bool> truth, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<IEnumerable<int>> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		HttpResponseMessage EnumerableGetRaw(IEnumerable<int> ids, 
			IEnumerable<bool> truth, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		Task EnumerableGetAsync(IEnumerable<int> ids, 
			IEnumerable<bool> truth, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<IEnumerable<int>> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<HttpResponseMessage> EnumerableGetRawAsync(IEnumerable<int> ids, 
			IEnumerable<bool> truth, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		void AttributeFormatting(int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<IEnumerable<int>> OKCallback = null, 
			Action<int> NoContentCallback = null, 
			Action<int> SeeOtherCallback = null, 
			Action<string> NotModifiedCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		HttpResponseMessage AttributeFormattingRaw(int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		Task AttributeFormattingAsync(int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<IEnumerable<int>> OKCallback = null, 
			Action<int> NoContentCallback = null, 
			Action<int> SeeOtherCallback = null, 
			Action<string> NotModifiedCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<HttpResponseMessage> AttributeFormattingRawAsync(int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		void QueryParameter(string name, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<string> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		HttpResponseMessage QueryParameterRaw(string name, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		Task QueryParameterAsync(string name, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<string> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<HttpResponseMessage> QueryParameterRawAsync(string name, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

	}


	internal class ValuesClient : IValuesClient
	{
		protected readonly ITestWebAppClientWrapper Client;
		protected readonly IHttpOverride HttpOverride;
		protected readonly IHttpSerializer Serializer;
		protected readonly IRequestModifier Modifier;

		public ValuesClient(ITestWebAppClientWrapper client, IHttpOverride httpOverride, IHttpSerializer serializer, IRequestModifier modifier)
		{
			Client = client;
			HttpOverride = httpOverride;
			Serializer = serializer;
			Modifier = modifier;
		}


		public IEnumerable<string> Get(int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";


			string url = $@"api/{controller}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			
			if(response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<IEnumerable<string>>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(IEnumerable<string>);
			}

		}


		public HttpResponseMessage GetRaw(int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";


			string url = $@"api/{controller}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}


		public async ValueTask<IEnumerable<string>> GetAsync(int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";


			string url = $@"api/{controller}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			
			if(response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<IEnumerable<string>>(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(IEnumerable<string>);
			}

		}


		public async ValueTask<HttpResponseMessage> GetRawAsync(int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";


			string url = $@"api/{controller}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}


		public string Get(int id, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";


			string url = $@"api/{controller}/{id}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("GEEET", "FULL")
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			
			if(response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(string);
			}

		}


		public HttpResponseMessage GetRaw(int id, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";


			string url = $@"api/{controller}/{id}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("GEEET", "FULL")
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}


		public async ValueTask<string> GetAsync(int id, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";


			string url = $@"api/{controller}/{id}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("GEEET", "FULL")
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			
			if(response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(string);
			}

		}


		public async ValueTask<HttpResponseMessage> GetRawAsync(int id, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";


			string url = $@"api/{controller}/{id}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("GEEET", "FULL")
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}


		public void Post(string value, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";


			string url = $@"api/{controller}?";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, value, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(Serializer.Serialize(value),cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, value, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public HttpResponseMessage PostRaw(string value, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";


			string url = $@"api/{controller}?";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, value, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(Serializer.Serialize(value),cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, value, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}


		public async Task PostAsync(string value, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";


			string url = $@"api/{controller}?";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, value, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(Serializer.Serialize(value),cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, value, response, cancellationToken).ConfigureAwait(false);
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public async ValueTask<HttpResponseMessage> PostRawAsync(string value, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";


			string url = $@"api/{controller}?";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, value, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(Serializer.Serialize(value),cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, value, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}


		public void Put(int id, 
			string value, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";


			string url = $@"api/{controller}/{id}?";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Put, url, value, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PutAsync(Serializer.Serialize(value),cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Put, url, value, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public HttpResponseMessage PutRaw(int id, 
			string value, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";


			string url = $@"api/{controller}/{id}?";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Put, url, value, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PutAsync(Serializer.Serialize(value),cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Put, url, value, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}


		public async Task PutAsync(int id, 
			string value, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";


			string url = $@"api/{controller}/{id}?";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Put, url, value, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PutAsync(Serializer.Serialize(value),cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Put, url, value, response, cancellationToken).ConfigureAwait(false);
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public async ValueTask<HttpResponseMessage> PutRawAsync(int id, 
			string value, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";


			string url = $@"api/{controller}/{id}?";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Put, url, value, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PutAsync(Serializer.Serialize(value),cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Put, url, value, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}


		public void Delete(int id, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			SecurityHeader auth = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";


			string url = $@"api/{controller}/{id}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Delete, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithAuth(auth)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.DeleteAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Delete, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public HttpResponseMessage DeleteRaw(int id, 
			int ControllerHeader = 0, 
			SecurityHeader auth = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";


			string url = $@"api/{controller}/{id}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Delete, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithAuth(auth)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.DeleteAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Delete, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}


		public async Task DeleteAsync(int id, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			SecurityHeader auth = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";


			string url = $@"api/{controller}/{id}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Delete, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithAuth(auth)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.DeleteAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Delete, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public async ValueTask<HttpResponseMessage> DeleteRawAsync(int id, 
			int ControllerHeader = 0, 
			SecurityHeader auth = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";


			string url = $@"api/{controller}/{id}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Delete, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithAuth(auth)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.DeleteAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Delete, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}


		public void CancellationTestEndpoint(int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "CancellationTestEndpoint";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public HttpResponseMessage CancellationTestEndpointRaw(int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "CancellationTestEndpoint";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}


		public async Task CancellationTestEndpointAsync(int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "CancellationTestEndpoint";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public async ValueTask<HttpResponseMessage> CancellationTestEndpointRawAsync(int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "CancellationTestEndpoint";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}


		public string HeaderTestString(String SpecialValue1, 
			string SpecialValue2, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "HeaderTestString";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("SpecialValue1", SpecialValue1)
				.WithHeader("SpecialValue2", SpecialValue2)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			
			if(response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(string);
			}

		}


		public HttpResponseMessage HeaderTestStringRaw(String SpecialValue1, 
			string SpecialValue2, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "HeaderTestString";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("SpecialValue1", SpecialValue1)
				.WithHeader("SpecialValue2", SpecialValue2)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}


		public async ValueTask<string> HeaderTestStringAsync(String SpecialValue1, 
			string SpecialValue2, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "HeaderTestString";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("SpecialValue1", SpecialValue1)
				.WithHeader("SpecialValue2", SpecialValue2)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			
			if(response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(string);
			}

		}


		public async ValueTask<HttpResponseMessage> HeaderTestStringRawAsync(String SpecialValue1, 
			string SpecialValue2, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "HeaderTestString";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("SpecialValue1", SpecialValue1)
				.WithHeader("SpecialValue2", SpecialValue2)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}


		public int HeaderTestInt(int SpecialValue1, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "HeaderTestInt";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("SpecialValue1", SpecialValue1)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			
			if(response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<int>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(int);
			}

		}


		public HttpResponseMessage HeaderTestIntRaw(int SpecialValue1, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "HeaderTestInt";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("SpecialValue1", SpecialValue1)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}


		public async ValueTask<int> HeaderTestIntAsync(int SpecialValue1, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "HeaderTestInt";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("SpecialValue1", SpecialValue1)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			
			if(response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<int>(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(int);
			}

		}


		public async ValueTask<HttpResponseMessage> HeaderTestIntRawAsync(int SpecialValue1, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "HeaderTestInt";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("SpecialValue1", SpecialValue1)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}


		public void FancyDtoReturn(int id, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<MyFancyDto> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{
			if(!int.TryParse(id.ToString(),out int idOUT))
			{
				throw new InvalidRouteException("Parameter id does not parse into an int.");
			}

			
			var controller = "Values";
			var action = "FancyDtoReturn";

			string url = $@"api/{controller}/{action}/{id}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				OKCallback?.Invoke(Serializer.Deserialize<MyFancyDto>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public HttpResponseMessage FancyDtoReturnRaw(int id, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{
			if(!int.TryParse(id.ToString(),out int idOUT))
			{
				throw new InvalidRouteException("Parameter id does not parse into an int.");
			}

			
			var controller = "Values";
			var action = "FancyDtoReturn";

			string url = $@"api/{controller}/{action}/{id}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}


		public async Task FancyDtoReturnAsync(int id, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<MyFancyDto> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{
			if(!int.TryParse(id.ToString(),out int idOUT))
			{
				throw new InvalidRouteException("Parameter id does not parse into an int.");
			}

			
			var controller = "Values";
			var action = "FancyDtoReturn";

			string url = $@"api/{controller}/{action}/{id}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				OKCallback?.Invoke(await Serializer.Deserialize<MyFancyDto>(response.Content).ConfigureAwait(false));
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public async ValueTask<HttpResponseMessage> FancyDtoReturnRawAsync(int id, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{
			if(!int.TryParse(id.ToString(),out int idOUT))
			{
				throw new InvalidRouteException("Parameter id does not parse into an int.");
			}

			
			var controller = "Values";
			var action = "FancyDtoReturn";

			string url = $@"api/{controller}/{action}/{id}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}


		public void TaskReturn(MyFancyDto dto, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "TaskReturn";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, dto, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(Serializer.Serialize(dto),cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public HttpResponseMessage TaskReturnRaw(MyFancyDto dto, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "TaskReturn";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, dto, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(Serializer.Serialize(dto),cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}


		public async Task TaskReturnAsync(MyFancyDto dto, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "TaskReturn";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, dto, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(Serializer.Serialize(dto),cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false);
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public async ValueTask<HttpResponseMessage> TaskReturnRawAsync(MyFancyDto dto, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "TaskReturn";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, dto, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(Serializer.Serialize(dto),cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}


		public MyFancyDto DtoForDto(MyFancyDto dto, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "DtoForDto";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, dto, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(Serializer.Serialize(dto),cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			
			if(response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<MyFancyDto>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(MyFancyDto);
			}

		}


		public HttpResponseMessage DtoForDtoRaw(MyFancyDto dto, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "DtoForDto";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, dto, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(Serializer.Serialize(dto),cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}


		public async ValueTask<MyFancyDto> DtoForDtoAsync(MyFancyDto dto, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "DtoForDto";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, dto, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(Serializer.Serialize(dto),cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false);
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			
			if(response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<MyFancyDto>(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(MyFancyDto);
			}

		}


		public async ValueTask<HttpResponseMessage> DtoForDtoRawAsync(MyFancyDto dto, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "DtoForDto";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, dto, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(Serializer.Serialize(dto),cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}


		public void GuidReturn(int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<Guid> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "GuidReturn";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				OKCallback?.Invoke(Serializer.Deserialize<Guid>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public HttpResponseMessage GuidReturnRaw(int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "GuidReturn";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}


		public async Task GuidReturnAsync(int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<Guid> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "GuidReturn";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				OKCallback?.Invoke(await Serializer.Deserialize<Guid>(response.Content).ConfigureAwait(false));
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public async ValueTask<HttpResponseMessage> GuidReturnRawAsync(int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "GuidReturn";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}


		public void DateTimeReturns(int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<DateTime> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "DateTimeReturns";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				OKCallback?.Invoke(Serializer.Deserialize<DateTime>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public HttpResponseMessage DateTimeReturnsRaw(int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "DateTimeReturns";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}


		public async Task DateTimeReturnsAsync(int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<DateTime> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "DateTimeReturns";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				OKCallback?.Invoke(await Serializer.Deserialize<DateTime>(response.Content).ConfigureAwait(false));
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public async ValueTask<HttpResponseMessage> DateTimeReturnsRawAsync(int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "DateTimeReturns";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}


		public void BoolReturns(int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<bool> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "BoolReturns";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				OKCallback?.Invoke(Serializer.Deserialize<bool>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public HttpResponseMessage BoolReturnsRaw(int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "BoolReturns";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}


		public async Task BoolReturnsAsync(int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<bool> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "BoolReturns";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				OKCallback?.Invoke(await Serializer.Deserialize<bool>(response.Content).ConfigureAwait(false));
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public async ValueTask<HttpResponseMessage> BoolReturnsRawAsync(int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "BoolReturns";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}


		public void PostWithNoBody(Guid id, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{
			if(!Guid.TryParse(id.ToString(),out Guid idOUT))
			{
				throw new InvalidRouteException("Parameter id does not parse into an Guid.");
			}

			
			var controller = "Values";
			var action = "PostWithNoBody";

			string url = $@"api/{controller}/{action}/{id}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(new StringContent(String.Empty),cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				OKCallback?.Invoke();
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public HttpResponseMessage PostWithNoBodyRaw(Guid id, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{
			if(!Guid.TryParse(id.ToString(),out Guid idOUT))
			{
				throw new InvalidRouteException("Parameter id does not parse into an Guid.");
			}

			
			var controller = "Values";
			var action = "PostWithNoBody";

			string url = $@"api/{controller}/{action}/{id}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(new StringContent(String.Empty),cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}


		public async Task PostWithNoBodyAsync(Guid id, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{
			if(!Guid.TryParse(id.ToString(),out Guid idOUT))
			{
				throw new InvalidRouteException("Parameter id does not parse into an Guid.");
			}

			
			var controller = "Values";
			var action = "PostWithNoBody";

			string url = $@"api/{controller}/{action}/{id}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(new StringContent(String.Empty),cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				OKCallback?.Invoke();
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public async ValueTask<HttpResponseMessage> PostWithNoBodyRawAsync(Guid id, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{
			if(!Guid.TryParse(id.ToString(),out Guid idOUT))
			{
				throw new InvalidRouteException("Parameter id does not parse into an Guid.");
			}

			
			var controller = "Values";
			var action = "PostWithNoBody";

			string url = $@"api/{controller}/{action}/{id}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(new StringContent(String.Empty),cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}


		public void ComplexPost(Guid testId, 
			MyFancyDto dto, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<MyFancyDto> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{
			if(!Guid.TryParse(testId.ToString(),out Guid testIdOUT))
			{
				throw new InvalidRouteException("Parameter testId does not parse into an Guid.");
			}

			
			var controller = "Values";
			var action = "ComplexPost";

			string url = $@"api/{controller}/{action}/{testId}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, dto, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(Serializer.Serialize(dto),cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				OKCallback?.Invoke(Serializer.Deserialize<MyFancyDto>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public HttpResponseMessage ComplexPostRaw(Guid testId, 
			MyFancyDto dto, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{
			if(!Guid.TryParse(testId.ToString(),out Guid testIdOUT))
			{
				throw new InvalidRouteException("Parameter testId does not parse into an Guid.");
			}

			
			var controller = "Values";
			var action = "ComplexPost";

			string url = $@"api/{controller}/{action}/{testId}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, dto, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(Serializer.Serialize(dto),cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}


		public async Task ComplexPostAsync(Guid testId, 
			MyFancyDto dto, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<MyFancyDto> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{
			if(!Guid.TryParse(testId.ToString(),out Guid testIdOUT))
			{
				throw new InvalidRouteException("Parameter testId does not parse into an Guid.");
			}

			
			var controller = "Values";
			var action = "ComplexPost";

			string url = $@"api/{controller}/{action}/{testId}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, dto, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(Serializer.Serialize(dto),cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false);
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				OKCallback?.Invoke(await Serializer.Deserialize<MyFancyDto>(response.Content).ConfigureAwait(false));
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public async ValueTask<HttpResponseMessage> ComplexPostRawAsync(Guid testId, 
			MyFancyDto dto, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{
			if(!Guid.TryParse(testId.ToString(),out Guid testIdOUT))
			{
				throw new InvalidRouteException("Parameter testId does not parse into an Guid.");
			}

			
			var controller = "Values";
			var action = "ComplexPost";

			string url = $@"api/{controller}/{action}/{testId}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, dto, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(Serializer.Serialize(dto),cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}


		public void PostWithSimpleBody(Guid id, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<Guid> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "PostWithSimpleBody";

			string url = $@"api/{controller}/{action}?";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, id, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(Serializer.Serialize(id),cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, id, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				OKCallback?.Invoke(Serializer.Deserialize<Guid>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public HttpResponseMessage PostWithSimpleBodyRaw(Guid id, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "PostWithSimpleBody";

			string url = $@"api/{controller}/{action}?";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, id, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(Serializer.Serialize(id),cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, id, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}


		public async Task PostWithSimpleBodyAsync(Guid id, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<Guid> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "PostWithSimpleBody";

			string url = $@"api/{controller}/{action}?";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, id, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(Serializer.Serialize(id),cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, id, response, cancellationToken).ConfigureAwait(false);
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				OKCallback?.Invoke(await Serializer.Deserialize<Guid>(response.Content).ConfigureAwait(false));
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public async ValueTask<HttpResponseMessage> PostWithSimpleBodyRawAsync(Guid id, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "PostWithSimpleBody";

			string url = $@"api/{controller}/{action}?";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, id, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(Serializer.Serialize(id),cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, id, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}


		public void EnumerableGet(IEnumerable<int> ids, 
			IEnumerable<bool> truth, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<IEnumerable<int>> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "EnumerableGet";

			string url = $@"api/{controller}/{action}?{string.Join("&",ids.Select(x => $"customIds={x}"))}&{string.Join("&",truth.Select(x => $"truth={x}"))}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				OKCallback?.Invoke(Serializer.Deserialize<IEnumerable<int>>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public HttpResponseMessage EnumerableGetRaw(IEnumerable<int> ids, 
			IEnumerable<bool> truth, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "EnumerableGet";

			string url = $@"api/{controller}/{action}?{string.Join("&",ids.Select(x => $"customIds={x}"))}&{string.Join("&",truth.Select(x => $"truth={x}"))}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}


		public async Task EnumerableGetAsync(IEnumerable<int> ids, 
			IEnumerable<bool> truth, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<IEnumerable<int>> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "EnumerableGet";

			string url = $@"api/{controller}/{action}?{string.Join("&",ids.Select(x => $"customIds={x}"))}&{string.Join("&",truth.Select(x => $"truth={x}"))}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				OKCallback?.Invoke(await Serializer.Deserialize<IEnumerable<int>>(response.Content).ConfigureAwait(false));
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public async ValueTask<HttpResponseMessage> EnumerableGetRawAsync(IEnumerable<int> ids, 
			IEnumerable<bool> truth, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "EnumerableGet";

			string url = $@"api/{controller}/{action}?{string.Join("&",ids.Select(x => $"customIds={x}"))}&{string.Join("&",truth.Select(x => $"truth={x}"))}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}


		public void AttributeFormatting(int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<IEnumerable<int>> OKCallback = null, 
			Action<int> NoContentCallback = null, 
			Action<int> SeeOtherCallback = null, 
			Action<string> NotModifiedCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "AttributeFormatting";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				OKCallback?.Invoke(Serializer.Deserialize<IEnumerable<int>>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(NoContentCallback != null && NoContentCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for NoContentCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.NoContent)
			{
				NoContentCallback?.Invoke(Serializer.Deserialize<int>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(SeeOtherCallback != null && SeeOtherCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for SeeOtherCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.SeeOther)
			{
				SeeOtherCallback?.Invoke(Serializer.Deserialize<int>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(NotModifiedCallback != null && NotModifiedCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for NotModifiedCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.NotModified)
			{
				NotModifiedCallback?.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public HttpResponseMessage AttributeFormattingRaw(int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "AttributeFormatting";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}


		public async Task AttributeFormattingAsync(int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<IEnumerable<int>> OKCallback = null, 
			Action<int> NoContentCallback = null, 
			Action<int> SeeOtherCallback = null, 
			Action<string> NotModifiedCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "AttributeFormatting";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				OKCallback?.Invoke(await Serializer.Deserialize<IEnumerable<int>>(response.Content).ConfigureAwait(false));
			}
			if(NoContentCallback != null && NoContentCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for NoContentCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.NoContent)
			{
				NoContentCallback?.Invoke(await Serializer.Deserialize<int>(response.Content).ConfigureAwait(false));
			}
			if(SeeOtherCallback != null && SeeOtherCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for SeeOtherCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.SeeOther)
			{
				SeeOtherCallback?.Invoke(await Serializer.Deserialize<int>(response.Content).ConfigureAwait(false));
			}
			if(NotModifiedCallback != null && NotModifiedCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for NotModifiedCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.NotModified)
			{
				NotModifiedCallback?.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public async ValueTask<HttpResponseMessage> AttributeFormattingRawAsync(int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "AttributeFormatting";

			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}


		public void QueryParameter(string name, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<string> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "QueryParameter";

			string url = $@"api/{controller}/{action}?name={name}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				OKCallback?.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public HttpResponseMessage QueryParameterRaw(string name, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "QueryParameter";

			string url = $@"api/{controller}/{action}?name={name}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}


		public async Task QueryParameterAsync(string name, 
			int ControllerHeader = 0, 
			Action<string> BadRequestCallback = null, 
			Action InternalServerErrorCallback = null, 
			Action<string> OKCallback = null, 
			Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "QueryParameter";

			string url = $@"api/{controller}/{action}?name={name}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if(BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				BadRequestCallback?.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
			}
			if(InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				InternalServerErrorCallback?.Invoke();
			}
			if(OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported. As they will run out of the scope of this call.");
			}
			if(response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				OKCallback?.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
			}
			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public async ValueTask<HttpResponseMessage> QueryParameterRawAsync(string name, 
			int ControllerHeader = 0, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			
			var controller = "Values";
			var action = "QueryParameter";

			string url = $@"api/{controller}/{action}?name={name}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithHeader("ControllerHeader", ControllerHeader)
				.WithHeader("Test", "EXTRA")
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.GetAsync(cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

	}


}


namespace TestWebApp.Clients.V1
{




	public interface ITestClient : ITestWebAppClient
	{
		
		void Endpoint(Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		HttpResponseMessage EndpointRaw(TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		Task EndpointAsync(Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<HttpResponseMessage> EndpointRawAsync(TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

	}


	internal class TestClient : ITestClient
	{
		public readonly ITestWebAppClientWrapper Client;
		public readonly IHttpOverride HttpOverride;
		public readonly IHttpSerializer Serializer;
		public readonly IRequestModifier Modifier;

		public TestClient(ITestWebAppClientWrapper client, IHttpOverride httpOverride, IHttpSerializer serializer, IRequestModifier modifier)
		{
			Client = client;
			HttpOverride = httpOverride;
			Serializer = serializer;
			Modifier = modifier;
		}


		public void Endpoint(Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			



			string url = $@"api/v1/test/endpoint";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(new StringContent(String.Empty),cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}


			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public HttpResponseMessage EndpointRaw(TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			



			string url = $@"api/v1/test/endpoint";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(new StringContent(String.Empty),cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}


		public async Task EndpointAsync(Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			



			string url = $@"api/v1/test/endpoint";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(new StringContent(String.Empty),cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false);
			}


			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public async ValueTask<HttpResponseMessage> EndpointRawAsync(TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			



			string url = $@"api/v1/test/endpoint";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(new StringContent(String.Empty),cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

	}


}


namespace TestWebApp.Clients.V2
{




	public interface ITestClient : ITestWebAppClient
	{
		
		void Endpoint(Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		HttpResponseMessage EndpointRaw(TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		Task EndpointAsync(Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

		
		ValueTask<HttpResponseMessage> EndpointRawAsync(TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken));

	}


	internal class TestClient : ITestClient
	{
		public readonly ITestWebAppClientWrapper Client;
		public readonly IHttpOverride HttpOverride;
		public readonly IHttpSerializer Serializer;
		public readonly IRequestModifier Modifier;

		public TestClient(ITestWebAppClientWrapper client, IHttpOverride httpOverride, IHttpSerializer serializer, IRequestModifier modifier)
		{
			Client = client;
			HttpOverride = httpOverride;
			Serializer = serializer;
			Modifier = modifier;
		}


		public void Endpoint(Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			



			string url = $@"api/v2/test/endpoint";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(new StringContent(String.Empty),cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}


			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public HttpResponseMessage EndpointRaw(TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			



			string url = $@"api/v2/test/endpoint";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			if(response == null)
			{
				response = Client.ClientWrapper
				.Request(url)
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(new StringContent(String.Empty),cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}


		public async Task EndpointAsync(Action<HttpResponseMessage> ResponseCallback = null, 
			TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			



			string url = $@"api/v2/test/endpoint";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(new StringContent(String.Empty),cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false);
			}


			if(ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported. As they will run out of the scope of this call.");
			}
			ResponseCallback?.Invoke(response);
			return;
		}


		public async ValueTask<HttpResponseMessage> EndpointRawAsync(TimeSpan? timeout = null, 
			IEnumerable<Cookie> cookies = null, 
			IDictionary<string, object> headers = null, 
			CancellationToken cancellationToken = default(CancellationToken))
		{

			



			string url = $@"api/v2/test/endpoint";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			if(response == null)
			{
				response = await Client.ClientWrapper
				.Request(url)
				.WithCookies(cookies)
				.WithHeaders(headers)
				.WithRequestModifiers(Modifier)
				.AllowAnyHttpStatus()
				.WithTimeout(timeout ?? Client.Timeout)
				.PostAsync(new StringContent(String.Empty),cancellationToken).ConfigureAwait(false);
				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

	}


}


