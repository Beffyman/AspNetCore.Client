//------------------------------------------------------------------------------
// <auto-generated>
//		This code was generated from a template.
//		Manual changes to this file may cause unexpected behavior in your application.
//		Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
//Requires nuget Microsoft.AspNetCore.SignalR.Client
//Requires nuget Microsoft.Extensions.Logging
//Requires nuget System.Threading.Channels
using AspNetCore.Client.Authorization;
using AspNetCore.Client.Exceptions;
using AspNetCore.Client.GeneratorExtensions;
using AspNetCore.Client.Http;
using AspNetCore.Client.RequestModifiers;
using AspNetCore.Client.Serializers;
using AspNetCore.Client;
using Flurl.Http;
using Microsoft.AspNetCore.Http.Connections.Client;
using Microsoft.AspNetCore.Http.Connections;
using Microsoft.AspNetCore.Mvc.ModelBinding;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.SignalR.Client;
using Microsoft.AspNetCore.SignalR.Protocol;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Net;
using System.Runtime.CompilerServices;
using System.Threading.Channels;
using System.Threading.Tasks;
using System.Threading;
using System;
using TestWebApp.Contracts;

namespace TestWebApp.Clients.Routes
{
	public static class FullClientRoutes
	{
		public static string GetQueryObject(MyFancyDto dto)
		{
			var controller = "Full";
			var action = "GetQueryObject";
			string url = $@"api/{controller}/{action}?{dto.GetQueryObjectString(nameof(dto)).ConfigureAwait(false).GetAwaiter().GetResult()}";
			return url;
		}
	}

	public static class InheritanceGenerationClientRoutes
	{
		public static string Get()
		{
			var controller = "InheritanceGeneration";
			string url = $@"api/{controller}/";
			return url;
		}
	}

	namespace FancySuffix
	{
		public static class NamespacedClientRoutes
		{
			public static string Test()
			{
				string url = $@"api/namespaced/test";
				return url;
			}

			public static string NewTest()
			{
				string url = $@"api/namespaced/NewTest123";
				return url;
			}

			public static string NewTest(int id)
			{
				string url = $@"api/namespaced/NewTest123/{id.EncodeForUrl()}";
				return url;
			}

			public static string OverrideTest()
			{
				string url = $@"api/namespaced/overwritten";
				return url;
			}

			public static string InheritTest()
			{
				string url = $@"api/namespaced/InheritTest";
				return url;
			}
		}
	}

	public static class RouteInheritanceClientRoutes
	{
		public static string NoRoute()
		{
			var controller = "RouteInheritance";
			var action = "NoRoute";
			string url = $@"api/{controller}/{action}/";
			return url;
		}
	}

	public static class ValuesClientRoutes
	{
		public static string GetEnumerable()
		{
			var controller = "Values";
			string url = $@"api/{controller}/";
			return url;
		}

		public static string GetEnumerableTask()
		{
			var controller = "Values";
			string url = $@"api/{controller}/getAsync";
			return url;
		}

		public static string GetFullyQualified()
		{
			var controller = "Values";
			string url = $@"api/{controller}/getQualified";
			return url;
		}

		public static string GetTuple()
		{
			var controller = "Values";
			string url = $@"api/{controller}/getTuple";
			return url;
		}

		public static string GetNestedTypes()
		{
			var controller = "Values";
			string url = $@"api/{controller}/getNested";
			return url;
		}

		public static string Get(int id)
		{
			var controller = "Values";
			string url = $@"api/{controller}/{id.EncodeForUrl()}";
			return url;
		}

		public static string Post()
		{
			var controller = "Values";
			string url = $@"api/{controller}/";
			return url;
		}

		public static string Put(int id)
		{
			var controller = "Values";
			string url = $@"api/{controller}/{id.EncodeForUrl()}";
			return url;
		}

		public static string Delete(int id)
		{
			var controller = "Values";
			string url = $@"api/{controller}/{id.EncodeForUrl()}";
			return url;
		}

		public static string ActionRoute()
		{
			var controller = "Values";
			var action = "ActionRouteAsync";
			string url = $@"api/{controller}/{action}";
			return url;
		}

		public static string TestPreFunc()
		{
			var controller = "Values";
			var action = "TestPreFunc";
			string url = $@"api/{controller}/{action}";
			return url;
		}

		public static string CancellationTestEndpoint()
		{
			var controller = "Values";
			var action = "CancellationTestEndpoint";
			string url = $@"api/{controller}/{action}";
			return url;
		}

		public static string NullableParameterOrdering(int id, bool deleted = false)
		{
			var controller = "Values";
			var action = "NullableParameterOrdering";
			string url = $@"api/{controller}/{action}/{id.EncodeForUrl()}?{nameof(deleted)}={deleted.EncodeForUrl()}";
			return url;
		}

		public static string HeaderTestString()
		{
			var controller = "Values";
			var action = "HeaderTestString";
			string url = $@"api/{controller}/{action}";
			return url;
		}

		public static string HeaderTestInt()
		{
			var controller = "Values";
			var action = "HeaderTestInt";
			string url = $@"api/{controller}/{action}";
			return url;
		}

		public static string FancyDtoReturn(int id)
		{
			var controller = "Values";
			var action = "FancyDtoReturn";
			string url = $@"api/{controller}/{action}/{id.EncodeForUrl()}";
			return url;
		}

		public static string TaskReturn()
		{
			var controller = "Values";
			var action = "TaskReturn";
			string url = $@"api/{controller}/{action}";
			return url;
		}

		public static string DtoForDto()
		{
			var controller = "Values";
			var action = "DtoForDto";
			string url = $@"api/{controller}/{action}";
			return url;
		}

		public static string GuidReturn()
		{
			var controller = "Values";
			var action = "GuidReturn";
			string url = $@"api/{controller}/{action}";
			return url;
		}

		public static string DateTimeReturns()
		{
			var controller = "Values";
			var action = "DateTimeReturns";
			string url = $@"api/{controller}/{action}";
			return url;
		}

		public static string BoolReturns()
		{
			var controller = "Values";
			var action = "BoolReturns";
			string url = $@"api/{controller}/{action}";
			return url;
		}

		public static string PostWithNoBody(Guid id)
		{
			var controller = "Values";
			var action = "PostWithNoBody";
			string url = $@"api/{controller}/{action}/{id.EncodeForUrl()}";
			return url;
		}

		public static string ComplexPost(Guid testId)
		{
			var controller = "Values";
			var action = "ComplexPost";
			string url = $@"api/{controller}/{action}/{testId.EncodeForUrl()}";
			return url;
		}

		public static string PostWithSimpleBody()
		{
			var controller = "Values";
			var action = "PostWithSimpleBody";
			string url = $@"api/{controller}/{action}";
			return url;
		}

		public static string EnumerableGet(IEnumerable<int> ids, IEnumerable<bool> truth)
		{
			var controller = "Values";
			var action = "EnumerableGet";
			string url = $@"api/{controller}/{action}?{string.Join("&", ids.Select(x => $"{nameof(ids)}={x.EncodeForUrl()}"))}&{string.Join("&", truth.Select(x => $"{nameof(truth)}={x.EncodeForUrl()}"))}";
			return url;
		}

		public static string EnumerableGetCustom(IEnumerable<int> customIds, IEnumerable<bool> truth)
		{
			var controller = "Values";
			var action = "EnumerableGetCustom";
			string url = $@"api/{controller}/{action}?{string.Join("&", customIds.Select(x => $"{nameof(customIds)}={x.EncodeForUrl()}"))}&{string.Join("&", truth.Select(x => $"{nameof(truth)}={x.EncodeForUrl()}"))}";
			return url;
		}

		public static string AttributeFormatting()
		{
			var controller = "Values";
			var action = "AttributeFormatting";
			string url = $@"api/{controller}/{action}";
			return url;
		}

		public static string QueryParameter(string name)
		{
			var controller = "Values";
			var action = "QueryParameter";
			string url = $@"api/{controller}/{action}?{nameof(name)}={name.EncodeForUrl()}";
			return url;
		}

		public static string FileReturn()
		{
			var controller = "Values";
			var action = "FileReturn";
			string url = $@"api/{controller}/{action}";
			return url;
		}

		public static string FileReturnResponseTypes(bool pass)
		{
			var controller = "Values";
			var action = "FileReturnResponseTypes";
			string url = $@"api/{controller}/{action}?{nameof(pass)}={pass.EncodeForUrl()}";
			return url;
		}

		public static string DefaultRouteConstraint(int? x = 5)
		{
			var controller = "Values";
			var action = "DefaultRouteConstraint";
			string url = $@"api/{controller}/{action}/defaultConstraint/{x.EncodeForUrl()}";
			return url;
		}

		public static string OptionalRouteConstraint(int? x)
		{
			var controller = "Values";
			var action = "OptionalRouteConstraint";
			string url = $@"api/{controller}/{action}/optional/{x.EncodeForUrl()}";
			return url;
		}

		public static string CheckDateTime(DateTime date)
		{
			var controller = "Values";
			var action = "CheckDateTime";
			string url = $@"api/{controller}/{action}/checkDate/{date.ToString("s", System.Globalization.CultureInfo.InvariantCulture).EncodeForUrl()}";
			return url;
		}

		public static string CheckDateTimeNullable(DateTime? date)
		{
			var controller = "Values";
			var action = "CheckDateTimeNullable";
			string url = $@"api/{controller}/{action}/checkDate/{date?.ToString("s", System.Globalization.CultureInfo.InvariantCulture).EncodeForUrl()}";
			return url;
		}

		public static string CheckDateTimeOffset(DateTimeOffset date)
		{
			var controller = "Values";
			var action = "CheckDateTimeOffset";
			string url = $@"api/{controller}/{action}/checkDateOffset/{date.ToString("s", System.Globalization.CultureInfo.InvariantCulture).EncodeForUrl()}";
			return url;
		}

		public static string CheckDateTimeOffsetNullable(DateTimeOffset? date)
		{
			var controller = "Values";
			var action = "CheckDateTimeOffsetNullable";
			string url = $@"api/{controller}/{action}/checkDateOffset/{date?.ToString("s", System.Globalization.CultureInfo.InvariantCulture).EncodeForUrl()}";
			return url;
		}

		public static string RouteConstraintCheck(string name, int id, bool val)
		{
			var controller = "Values";
			var action = "RouteConstraintCheck";
			string url = $@"api/{controller}/{action}/routeCheck/{name.EncodeForUrl()}/{id.EncodeForUrl()}/{val.EncodeForUrl()}";
			return url;
		}

		public static string DuplicateMethodReturnAndResponse()
		{
			var controller = "Values";
			var action = "DuplicateMethodReturnAndResponse";
			string url = $@"api/{controller}/{action}";
			return url;
		}

		public static string ProblemDetailsRequest()
		{
			var controller = "Values";
			var action = "ProblemDetailsRequest";
			string url = $@"api/{controller}/{action}";
			return url;
		}

		public static string ModelStateBadRequest()
		{
			var controller = "Values";
			var action = "ModelStateBadRequest";
			string url = $@"api/{controller}/{action}";
			return url;
		}

		public static string UrlEncodingCheck(string code)
		{
			var controller = "Values";
			var action = "UrlEncodingCheck";
			string url = $@"api/{controller}/{action}/{code.EncodeForUrl()}";
			return url;
		}

		public static string UrlEncodingQueryCheck(string code)
		{
			var controller = "Values";
			var action = "UrlEncodingQueryCheck";
			string url = $@"api/{controller}/{action}?{nameof(code)}={code.EncodeForUrl()}";
			return url;
		}
	}
}

namespace TestWebApp.Clients.V1.Routes
{
	public static class TestClientRoutes
	{
		public static string Endpoint()
		{
			string url = $@"api/v1/test/endpoint";
			return url;
		}
	}
}

namespace TestWebApp.Clients.V2.Routes
{
	public static class TestClientRoutes
	{
		public static string Endpoint()
		{
			string url = $@"api/v2/test/endpoint";
			return url;
		}
	}
}

namespace TestWebApp.Clients.V3.Routes
{
	public static class TestQueryClientRoutes
	{
		public static string Endpoint(int index)
		{
			var controller = "TestQuery";
			string url = $@"api/{controller}/endpoint/{index.EncodeForUrl()}?api-version=3";
			return url;
		}
	}
}

namespace TestWebApp.Clients.V3_0.Routes
{
	public static class TestRouteClientRoutes
	{
		public static string Endpoint(int index)
		{
			var controller = "TestRoute";
			string url = $@"api/v3.0/{controller}/endpoint/{index.EncodeForUrl()}";
			return url;
		}
	}
}

namespace TestWebApp.Clients
{
#warning DuplicateParameterErrorController is misconfigured for generation :: Endpoint DuplicateParameterError.ErrorResponses has multiple parameters of the same name defined. id
#warning InheritanceErrorsController is misconfigured for generation :: Endpoint has multiple headers of the same key defined. TestInheritance
#warning ResponseTypeErrorController is misconfigured for generation :: Endpoint has multiple response types of the same status defined. OK
#warning ErrorHub is misconfigured for generation :: Hub has multiple messages with different parameters defined. ReceiveMessage
	public static class TestWebAppClientInstaller
	{
		/// <summary>
		/// Register the autogenerated clients into the container with a lifecycle of scoped.
		/// </summary>
		/// <param name="services"></param>
		/// <param name="configure">Overrides for client configuration</param>
		/// <returns></returns>
		public static IServiceCollection AddTestWebClients(this IServiceCollection services, Action<ClientConfiguration> configure)
		{
			var configuration = new ClientConfiguration();
			configuration.RegisterClientWrapperCreator<ITestWebAppClient>(TestWebAppClientWrapper.Create);
			configuration.UseClientWrapper<ITestWebAppClientWrapper, TestWebAppClientWrapper>((provider) => new TestWebAppClientWrapper(provider.GetService<Func<ITestWebAppClient, IFlurlClient>>(), configuration.GetSettings(), provider));
			configure?.Invoke(configuration);
			services.AddScoped<ITestWebAppClientRepository, TestWebAppClientRepository>();
			services.AddScoped<ITestWebAppClientV1Repository, TestWebAppClientV1Repository>();
			services.AddScoped<ITestWebAppClientV2Repository, TestWebAppClientV2Repository>();
			services.AddScoped<ITestWebAppClientV3Repository, TestWebAppClientV3Repository>();
			services.AddScoped<ITestWebAppClientV3_0Repository, TestWebAppClientV3_0Repository>();
			services.AddScoped<IFullClient, FullClient>();
			services.AddScoped<IInheritanceGenerationClient, InheritanceGenerationClient>();
			services.AddScoped<FancySuffix.INamespacedClient, FancySuffix.NamespacedClient>();
			services.AddScoped<IRouteInheritanceClient, RouteInheritanceClient>();
			services.AddScoped<V1.ITestClient, V1.TestClient>();
			services.AddScoped<V2.ITestClient, V2.TestClient>();
			services.AddScoped<V3.ITestQueryClient, V3.TestQueryClient>();
			services.AddScoped<V3_0.ITestRouteClient, V3_0.TestRouteClient>();
			services.AddScoped<IValuesClient, ValuesClient>();
			return configuration.ApplyConfiguration<ITestWebAppClient>(services);
		}
	}

	public interface ITestWebAppClientWrapper : IClientWrapper
	{
	}

	public class TestWebAppClientWrapper : ITestWebAppClientWrapper
	{
		public TimeSpan Timeout
		{
			get;
			internal set;
		}

		public IFlurlClient ClientWrapper
		{
			get;
			internal set;
		}

		public TestWebAppClientWrapper(Func<ITestWebAppClient, IFlurlClient> client, ClientSettings settings, IServiceProvider provider)
		{
			ClientWrapper = client(null);
			if (settings.BaseAddress != null)
			{
				ClientWrapper.BaseUrl = settings.BaseAddress(provider);
			}

			Timeout = settings.Timeout;
		}

		public static ITestWebAppClientWrapper Create(Func<ITestWebAppClient, IFlurlClient> client, ClientSettings settings, IServiceProvider provider)
		{
			return new TestWebAppClientWrapper(client, settings, provider);
		}
	}

	public interface ITestWebAppClient : IClient
	{
	}

	public interface ITestWebAppClientRepository
	{
		IFullClient Full
		{
			get;
		}

		IInheritanceGenerationClient InheritanceGeneration
		{
			get;
		}

		FancySuffix.INamespacedClient Namespaced
		{
			get;
		}

		IRouteInheritanceClient RouteInheritance
		{
			get;
		}

		IValuesClient Values
		{
			get;
		}
	}

	internal class TestWebAppClientRepository : ITestWebAppClientRepository
	{
		public IFullClient Full
		{
			get;
		}

		public IInheritanceGenerationClient InheritanceGeneration
		{
			get;
		}

		public FancySuffix.INamespacedClient Namespaced
		{
			get;
		}

		public IRouteInheritanceClient RouteInheritance
		{
			get;
		}

		public IValuesClient Values
		{
			get;
		}

		public TestWebAppClientRepository(IFullClient param_full, IInheritanceGenerationClient param_inheritancegeneration, FancySuffix.INamespacedClient param_namespaced, IRouteInheritanceClient param_routeinheritance, IValuesClient param_values)
		{
			this.Full = param_full;
			this.InheritanceGeneration = param_inheritancegeneration;
			this.Namespaced = param_namespaced;
			this.RouteInheritance = param_routeinheritance;
			this.Values = param_values;
		}
	}

	public interface ITestWebAppClientV1Repository
	{
		V1.ITestClient Test
		{
			get;
		}
	}

	internal class TestWebAppClientV1Repository : ITestWebAppClientV1Repository
	{
		public V1.ITestClient Test
		{
			get;
		}

		public TestWebAppClientV1Repository(V1.ITestClient param_test)
		{
			this.Test = param_test;
		}
	}

	public interface ITestWebAppClientV2Repository
	{
		V2.ITestClient Test
		{
			get;
		}
	}

	internal class TestWebAppClientV2Repository : ITestWebAppClientV2Repository
	{
		public V2.ITestClient Test
		{
			get;
		}

		public TestWebAppClientV2Repository(V2.ITestClient param_test)
		{
			this.Test = param_test;
		}
	}

	public interface ITestWebAppClientV3Repository
	{
		V3.ITestQueryClient TestQuery
		{
			get;
		}
	}

	internal class TestWebAppClientV3Repository : ITestWebAppClientV3Repository
	{
		public V3.ITestQueryClient TestQuery
		{
			get;
		}

		public TestWebAppClientV3Repository(V3.ITestQueryClient param_testquery)
		{
			this.TestQuery = param_testquery;
		}
	}

	public interface ITestWebAppClientV3_0Repository
	{
		V3_0.ITestRouteClient TestRoute
		{
			get;
		}
	}

	internal class TestWebAppClientV3_0Repository : ITestWebAppClientV3_0Repository
	{
		public V3_0.ITestRouteClient TestRoute
		{
			get;
		}

		public TestWebAppClientV3_0Repository(V3_0.ITestRouteClient param_testroute)
		{
			this.TestRoute = param_testroute;
		}
	}
}

namespace TestWebApp.Clients
{
	public interface IFullClient : ITestWebAppClient
	{
		MyFancyDto GetQueryObject(MyFancyDto dto, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage GetQueryObjectRaw(MyFancyDto dto, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<MyFancyDto> GetQueryObjectAsync(MyFancyDto dto, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> GetQueryObjectRawAsync(MyFancyDto dto, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
	}

	internal class FullClient : IFullClient
	{
		protected readonly ITestWebAppClientWrapper Client;
		protected readonly IHttpOverride HttpOverride;
		protected readonly IHttpSerializer Serializer;
		protected readonly IHttpRequestModifier Modifier;
		public FullClient(ITestWebAppClientWrapper param_client, Func<ITestWebAppClient, IHttpOverride> param_httpoverride, Func<ITestWebAppClient, IHttpSerializer> param_serializer, Func<ITestWebAppClient, IHttpRequestModifier> param_modifier)
		{
			Client = param_client;
			HttpOverride = param_httpoverride(this);
			Serializer = param_serializer(this);
			Modifier = param_modifier(this);
		}

		public MyFancyDto GetQueryObject(MyFancyDto dto, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Full";
			var action = "GetQueryObject";
			string url = $@"api/{controller}/{action}?{dto.GetQueryObjectString(nameof(dto)).ConfigureAwait(false).GetAwaiter().GetResult()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(MyFancyDto);
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<MyFancyDto>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(MyFancyDto);
			}
		}

		public HttpResponseMessage GetQueryObjectRaw(MyFancyDto dto, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Full";
			var action = "GetQueryObject";
			string url = $@"api/{controller}/{action}?{dto.GetQueryObjectString(nameof(dto)).ConfigureAwait(false).GetAwaiter().GetResult()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async ValueTask<MyFancyDto> GetQueryObjectAsync(MyFancyDto dto, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Full";
			var action = "GetQueryObject";
			string url = $@"api/{controller}/{action}?{await dto.GetQueryObjectString(nameof(dto)).ConfigureAwait(false)}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(MyFancyDto);
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<MyFancyDto>(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(MyFancyDto);
			}
		}

		public async ValueTask<HttpResponseMessage> GetQueryObjectRawAsync(MyFancyDto dto, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Full";
			var action = "GetQueryObject";
			string url = $@"api/{controller}/{action}?{await dto.GetQueryObjectString(nameof(dto)).ConfigureAwait(false)}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}
	}

	public interface IInheritanceGenerationClient : ITestWebAppClient
	{
		void Get(Action<string> BadRequestCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage GetRaw(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task GetAsync(Action<string> BadRequestCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> GetRawAsync(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
	}

	internal class InheritanceGenerationClient : IInheritanceGenerationClient
	{
		protected readonly ITestWebAppClientWrapper Client;
		protected readonly IHttpOverride HttpOverride;
		protected readonly IHttpSerializer Serializer;
		protected readonly IHttpRequestModifier Modifier;
		public InheritanceGenerationClient(ITestWebAppClientWrapper param_client, Func<ITestWebAppClient, IHttpOverride> param_httpoverride, Func<ITestWebAppClient, IHttpSerializer> param_serializer, Func<ITestWebAppClient, IHttpRequestModifier> param_modifier)
		{
			Client = param_client;
			HttpOverride = param_httpoverride(this);
			Serializer = param_serializer(this);
			Modifier = param_modifier(this);
		}

		public void Get(Action<string> BadRequestCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "InheritanceGeneration";
			string url = $@"api/{controller}/";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage GetRaw(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "InheritanceGeneration";
			string url = $@"api/{controller}/";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task GetAsync(Action<string> BadRequestCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "InheritanceGeneration";
			string url = $@"api/{controller}/";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> GetRawAsync(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "InheritanceGeneration";
			string url = $@"api/{controller}/";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}
	}

	namespace FancySuffix
	{
		public interface INamespacedClient : ITestWebAppClient
		{
			void Test(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
			HttpResponseMessage TestRaw(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
			Task TestAsync(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
			ValueTask<HttpResponseMessage> TestRawAsync(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
			void NewTest(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
			HttpResponseMessage NewTestRaw(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
			Task NewTestAsync(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
			ValueTask<HttpResponseMessage> NewTestRawAsync(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
			void NewTest(int id, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
			HttpResponseMessage NewTestRaw(int id, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
			Task NewTestAsync(int id, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
			ValueTask<HttpResponseMessage> NewTestRawAsync(int id, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
			void OverrideTest(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
			HttpResponseMessage OverrideTestRaw(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
			Task OverrideTestAsync(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
			ValueTask<HttpResponseMessage> OverrideTestRawAsync(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
			void InheritTest(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
			HttpResponseMessage InheritTestRaw(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
			Task InheritTestAsync(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
			ValueTask<HttpResponseMessage> InheritTestRawAsync(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		}

		internal class NamespacedClient : INamespacedClient
		{
			protected readonly ITestWebAppClientWrapper Client;
			protected readonly IHttpOverride HttpOverride;
			protected readonly IHttpSerializer Serializer;
			protected readonly IHttpRequestModifier Modifier;
			public NamespacedClient(ITestWebAppClientWrapper param_client, Func<ITestWebAppClient, IHttpOverride> param_httpoverride, Func<ITestWebAppClient, IHttpSerializer> param_serializer, Func<ITestWebAppClient, IHttpRequestModifier> param_modifier)
			{
				Client = param_client;
				HttpOverride = param_httpoverride(this);
				Serializer = param_serializer(this);
				Modifier = param_modifier(this);
			}

			public void Test(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
			{
				string url = $@"api/namespaced/test";
				HttpResponseMessage response = null;
				response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				bool responseHandled = response != null;
				if (response == null)
				{
					try
					{
						response = Client.ClientWrapper.Request(url).WithHeader("TestInheritance", "WORKS").WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
					}
					catch (FlurlHttpException fhex)
					{
						if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
						{
							throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
						}

						if (ExceptionCallback != null)
						{
							responseHandled = true;
							ExceptionCallback?.Invoke(fhex);
						}
						else
						{
							throw fhex;
						}

						return;
					}

					HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}

				if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
				{
					throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
				}

				if (ResponseCallback != null)
				{
					responseHandled = true;
					ResponseCallback.Invoke(response);
				}

				return;
			}

			public HttpResponseMessage TestRaw(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
			{
				string url = $@"api/namespaced/test";
				HttpResponseMessage response = null;
				response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				bool responseHandled = response != null;
				if (response == null)
				{
					try
					{
						response = Client.ClientWrapper.Request(url).WithHeader("TestInheritance", "WORKS").WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
					}
					catch (FlurlHttpException fhex)
					{
						if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
						{
							throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
						}

						if (ExceptionCallback != null)
						{
							responseHandled = true;
							ExceptionCallback?.Invoke(fhex);
						}
						else
						{
							throw fhex;
						}

						return null;
					}

					HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}

				return response;
			}

			public async Task TestAsync(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
			{
				string url = $@"api/namespaced/test";
				HttpResponseMessage response = null;
				response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
				bool responseHandled = response != null;
				if (response == null)
				{
					try
					{
						response = await Client.ClientWrapper.Request(url).WithHeader("TestInheritance", "WORKS").WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
					}
					catch (FlurlHttpException fhex)
					{
						if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
						{
							throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
						}

						if (ExceptionCallback != null)
						{
							responseHandled = true;
							ExceptionCallback?.Invoke(fhex);
						}
						else
						{
							throw fhex;
						}

						return;
					}

					await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
				}

				if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
				{
					throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
				}

				if (ResponseCallback != null)
				{
					responseHandled = true;
					ResponseCallback.Invoke(response);
				}

				return;
			}

			public async ValueTask<HttpResponseMessage> TestRawAsync(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
			{
				string url = $@"api/namespaced/test";
				HttpResponseMessage response = null;
				response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
				bool responseHandled = response != null;
				if (response == null)
				{
					try
					{
						response = await Client.ClientWrapper.Request(url).WithHeader("TestInheritance", "WORKS").WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
					}
					catch (FlurlHttpException fhex)
					{
						if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
						{
							throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
						}

						if (ExceptionCallback != null)
						{
							responseHandled = true;
							ExceptionCallback?.Invoke(fhex);
						}
						else
						{
							throw fhex;
						}

						return null;
					}

					await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
				}

				return response;
			}

			public void NewTest(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
			{
				string url = $@"api/namespaced/NewTest123";
				HttpResponseMessage response = null;
				response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				bool responseHandled = response != null;
				if (response == null)
				{
					try
					{
						response = Client.ClientWrapper.Request(url).WithHeader("TestInheritance", "WORKS").WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
					}
					catch (FlurlHttpException fhex)
					{
						if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
						{
							throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
						}

						if (ExceptionCallback != null)
						{
							responseHandled = true;
							ExceptionCallback?.Invoke(fhex);
						}
						else
						{
							throw fhex;
						}

						return;
					}

					HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}

				if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
				{
					throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
				}

				if (ResponseCallback != null)
				{
					responseHandled = true;
					ResponseCallback.Invoke(response);
				}

				return;
			}

			public HttpResponseMessage NewTestRaw(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
			{
				string url = $@"api/namespaced/NewTest123";
				HttpResponseMessage response = null;
				response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				bool responseHandled = response != null;
				if (response == null)
				{
					try
					{
						response = Client.ClientWrapper.Request(url).WithHeader("TestInheritance", "WORKS").WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
					}
					catch (FlurlHttpException fhex)
					{
						if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
						{
							throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
						}

						if (ExceptionCallback != null)
						{
							responseHandled = true;
							ExceptionCallback?.Invoke(fhex);
						}
						else
						{
							throw fhex;
						}

						return null;
					}

					HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}

				return response;
			}

			public async Task NewTestAsync(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
			{
				string url = $@"api/namespaced/NewTest123";
				HttpResponseMessage response = null;
				response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
				bool responseHandled = response != null;
				if (response == null)
				{
					try
					{
						response = await Client.ClientWrapper.Request(url).WithHeader("TestInheritance", "WORKS").WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
					}
					catch (FlurlHttpException fhex)
					{
						if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
						{
							throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
						}

						if (ExceptionCallback != null)
						{
							responseHandled = true;
							ExceptionCallback?.Invoke(fhex);
						}
						else
						{
							throw fhex;
						}

						return;
					}

					await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
				}

				if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
				{
					throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
				}

				if (ResponseCallback != null)
				{
					responseHandled = true;
					ResponseCallback.Invoke(response);
				}

				return;
			}

			public async ValueTask<HttpResponseMessage> NewTestRawAsync(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
			{
				string url = $@"api/namespaced/NewTest123";
				HttpResponseMessage response = null;
				response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
				bool responseHandled = response != null;
				if (response == null)
				{
					try
					{
						response = await Client.ClientWrapper.Request(url).WithHeader("TestInheritance", "WORKS").WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
					}
					catch (FlurlHttpException fhex)
					{
						if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
						{
							throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
						}

						if (ExceptionCallback != null)
						{
							responseHandled = true;
							ExceptionCallback?.Invoke(fhex);
						}
						else
						{
							throw fhex;
						}

						return null;
					}

					await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
				}

				return response;
			}

			public void NewTest(int id, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
			{
				if (!int.TryParse(id.ToString(), out _))
				{
					throw new InvalidRouteException("Parameter id does not parse into an int.");
				}

				string url = $@"api/namespaced/NewTest123/{id.EncodeForUrl()}";
				HttpResponseMessage response = null;
				response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				bool responseHandled = response != null;
				if (response == null)
				{
					try
					{
						response = Client.ClientWrapper.Request(url).WithHeader("TestInheritance", "WORKS").WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
					}
					catch (FlurlHttpException fhex)
					{
						if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
						{
							throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
						}

						if (ExceptionCallback != null)
						{
							responseHandled = true;
							ExceptionCallback?.Invoke(fhex);
						}
						else
						{
							throw fhex;
						}

						return;
					}

					HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}

				if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
				{
					throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
				}

				if (ResponseCallback != null)
				{
					responseHandled = true;
					ResponseCallback.Invoke(response);
				}

				return;
			}

			public HttpResponseMessage NewTestRaw(int id, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
			{
				if (!int.TryParse(id.ToString(), out _))
				{
					throw new InvalidRouteException("Parameter id does not parse into an int.");
				}

				string url = $@"api/namespaced/NewTest123/{id.EncodeForUrl()}";
				HttpResponseMessage response = null;
				response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				bool responseHandled = response != null;
				if (response == null)
				{
					try
					{
						response = Client.ClientWrapper.Request(url).WithHeader("TestInheritance", "WORKS").WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
					}
					catch (FlurlHttpException fhex)
					{
						if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
						{
							throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
						}

						if (ExceptionCallback != null)
						{
							responseHandled = true;
							ExceptionCallback?.Invoke(fhex);
						}
						else
						{
							throw fhex;
						}

						return null;
					}

					HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}

				return response;
			}

			public async Task NewTestAsync(int id, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
			{
				if (!int.TryParse(id.ToString(), out _))
				{
					throw new InvalidRouteException("Parameter id does not parse into an int.");
				}

				string url = $@"api/namespaced/NewTest123/{id.EncodeForUrl()}";
				HttpResponseMessage response = null;
				response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
				bool responseHandled = response != null;
				if (response == null)
				{
					try
					{
						response = await Client.ClientWrapper.Request(url).WithHeader("TestInheritance", "WORKS").WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
					}
					catch (FlurlHttpException fhex)
					{
						if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
						{
							throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
						}

						if (ExceptionCallback != null)
						{
							responseHandled = true;
							ExceptionCallback?.Invoke(fhex);
						}
						else
						{
							throw fhex;
						}

						return;
					}

					await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
				}

				if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
				{
					throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
				}

				if (ResponseCallback != null)
				{
					responseHandled = true;
					ResponseCallback.Invoke(response);
				}

				return;
			}

			public async ValueTask<HttpResponseMessage> NewTestRawAsync(int id, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
			{
				if (!int.TryParse(id.ToString(), out _))
				{
					throw new InvalidRouteException("Parameter id does not parse into an int.");
				}

				string url = $@"api/namespaced/NewTest123/{id.EncodeForUrl()}";
				HttpResponseMessage response = null;
				response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
				bool responseHandled = response != null;
				if (response == null)
				{
					try
					{
						response = await Client.ClientWrapper.Request(url).WithHeader("TestInheritance", "WORKS").WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
					}
					catch (FlurlHttpException fhex)
					{
						if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
						{
							throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
						}

						if (ExceptionCallback != null)
						{
							responseHandled = true;
							ExceptionCallback?.Invoke(fhex);
						}
						else
						{
							throw fhex;
						}

						return null;
					}

					await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
				}

				return response;
			}

			public void OverrideTest(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
			{
				string url = $@"api/namespaced/overwritten";
				HttpResponseMessage response = null;
				response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				bool responseHandled = response != null;
				if (response == null)
				{
					try
					{
						response = Client.ClientWrapper.Request(url).WithHeader("TestInheritance", "WORKS").WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
					}
					catch (FlurlHttpException fhex)
					{
						if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
						{
							throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
						}

						if (ExceptionCallback != null)
						{
							responseHandled = true;
							ExceptionCallback?.Invoke(fhex);
						}
						else
						{
							throw fhex;
						}

						return;
					}

					HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}

				if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
				{
					throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
				}

				if (ResponseCallback != null)
				{
					responseHandled = true;
					ResponseCallback.Invoke(response);
				}

				return;
			}

			public HttpResponseMessage OverrideTestRaw(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
			{
				string url = $@"api/namespaced/overwritten";
				HttpResponseMessage response = null;
				response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				bool responseHandled = response != null;
				if (response == null)
				{
					try
					{
						response = Client.ClientWrapper.Request(url).WithHeader("TestInheritance", "WORKS").WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
					}
					catch (FlurlHttpException fhex)
					{
						if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
						{
							throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
						}

						if (ExceptionCallback != null)
						{
							responseHandled = true;
							ExceptionCallback?.Invoke(fhex);
						}
						else
						{
							throw fhex;
						}

						return null;
					}

					HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}

				return response;
			}

			public async Task OverrideTestAsync(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
			{
				string url = $@"api/namespaced/overwritten";
				HttpResponseMessage response = null;
				response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
				bool responseHandled = response != null;
				if (response == null)
				{
					try
					{
						response = await Client.ClientWrapper.Request(url).WithHeader("TestInheritance", "WORKS").WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
					}
					catch (FlurlHttpException fhex)
					{
						if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
						{
							throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
						}

						if (ExceptionCallback != null)
						{
							responseHandled = true;
							ExceptionCallback?.Invoke(fhex);
						}
						else
						{
							throw fhex;
						}

						return;
					}

					await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
				}

				if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
				{
					throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
				}

				if (ResponseCallback != null)
				{
					responseHandled = true;
					ResponseCallback.Invoke(response);
				}

				return;
			}

			public async ValueTask<HttpResponseMessage> OverrideTestRawAsync(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
			{
				string url = $@"api/namespaced/overwritten";
				HttpResponseMessage response = null;
				response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
				bool responseHandled = response != null;
				if (response == null)
				{
					try
					{
						response = await Client.ClientWrapper.Request(url).WithHeader("TestInheritance", "WORKS").WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
					}
					catch (FlurlHttpException fhex)
					{
						if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
						{
							throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
						}

						if (ExceptionCallback != null)
						{
							responseHandled = true;
							ExceptionCallback?.Invoke(fhex);
						}
						else
						{
							throw fhex;
						}

						return null;
					}

					await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
				}

				return response;
			}

			public void InheritTest(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
			{
				string url = $@"api/namespaced/InheritTest";
				HttpResponseMessage response = null;
				response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				bool responseHandled = response != null;
				if (response == null)
				{
					try
					{
						response = Client.ClientWrapper.Request(url).WithHeader("TestInheritance", "WORKS").WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
					}
					catch (FlurlHttpException fhex)
					{
						if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
						{
							throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
						}

						if (ExceptionCallback != null)
						{
							responseHandled = true;
							ExceptionCallback?.Invoke(fhex);
						}
						else
						{
							throw fhex;
						}

						return;
					}

					HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}

				if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
				{
					throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
				}

				if (ResponseCallback != null)
				{
					responseHandled = true;
					ResponseCallback.Invoke(response);
				}

				return;
			}

			public HttpResponseMessage InheritTestRaw(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
			{
				string url = $@"api/namespaced/InheritTest";
				HttpResponseMessage response = null;
				response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				bool responseHandled = response != null;
				if (response == null)
				{
					try
					{
						response = Client.ClientWrapper.Request(url).WithHeader("TestInheritance", "WORKS").WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
					}
					catch (FlurlHttpException fhex)
					{
						if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
						{
							throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
						}

						if (ExceptionCallback != null)
						{
							responseHandled = true;
							ExceptionCallback?.Invoke(fhex);
						}
						else
						{
							throw fhex;
						}

						return null;
					}

					HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}

				return response;
			}

			public async Task InheritTestAsync(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
			{
				string url = $@"api/namespaced/InheritTest";
				HttpResponseMessage response = null;
				response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
				bool responseHandled = response != null;
				if (response == null)
				{
					try
					{
						response = await Client.ClientWrapper.Request(url).WithHeader("TestInheritance", "WORKS").WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
					}
					catch (FlurlHttpException fhex)
					{
						if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
						{
							throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
						}

						if (ExceptionCallback != null)
						{
							responseHandled = true;
							ExceptionCallback?.Invoke(fhex);
						}
						else
						{
							throw fhex;
						}

						return;
					}

					await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
				}

				if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
				{
					throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
				}

				if (ResponseCallback != null)
				{
					responseHandled = true;
					ResponseCallback.Invoke(response);
				}

				return;
			}

			public async ValueTask<HttpResponseMessage> InheritTestRawAsync(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
			{
				string url = $@"api/namespaced/InheritTest";
				HttpResponseMessage response = null;
				response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
				bool responseHandled = response != null;
				if (response == null)
				{
					try
					{
						response = await Client.ClientWrapper.Request(url).WithHeader("TestInheritance", "WORKS").WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
					}
					catch (FlurlHttpException fhex)
					{
						if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
						{
							throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
						}

						if (ExceptionCallback != null)
						{
							responseHandled = true;
							ExceptionCallback?.Invoke(fhex);
						}
						else
						{
							throw fhex;
						}

						return null;
					}

					await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
				}

				return response;
			}
		}
	}

	public interface IRouteInheritanceClient : ITestWebAppClient
	{
		void NoRoute(Action OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage NoRouteRaw(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task NoRouteAsync(Action OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> NoRouteRawAsync(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
	}

	internal class RouteInheritanceClient : IRouteInheritanceClient
	{
		protected readonly ITestWebAppClientWrapper Client;
		protected readonly IHttpOverride HttpOverride;
		protected readonly IHttpSerializer Serializer;
		protected readonly IHttpRequestModifier Modifier;
		public RouteInheritanceClient(ITestWebAppClientWrapper param_client, Func<ITestWebAppClient, IHttpOverride> param_httpoverride, Func<ITestWebAppClient, IHttpSerializer> param_serializer, Func<ITestWebAppClient, IHttpRequestModifier> param_modifier)
		{
			Client = param_client;
			HttpOverride = param_httpoverride(this);
			Serializer = param_serializer(this);
			Modifier = param_modifier(this);
		}

		public void NoRoute(Action OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "RouteInheritance";
			var action = "NoRoute";
			string url = $@"api/{controller}/{action}/";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage NoRouteRaw(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "RouteInheritance";
			var action = "NoRoute";
			string url = $@"api/{controller}/{action}/";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task NoRouteAsync(Action OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "RouteInheritance";
			var action = "NoRoute";
			string url = $@"api/{controller}/{action}/";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> NoRouteRawAsync(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "RouteInheritance";
			var action = "NoRoute";
			string url = $@"api/{controller}/{action}/";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}
	}

	public interface IValuesClient : ITestWebAppClient
	{
		IEnumerable<string> GetEnumerable(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage GetEnumerableRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<IEnumerable<string>> GetEnumerableAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> GetEnumerableRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		IEnumerable<string> GetEnumerableTask(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage GetEnumerableTaskRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<IEnumerable<string>> GetEnumerableTaskAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> GetEnumerableTaskRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		System.Collections.Generic.IEnumerable<string> GetFullyQualified(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage GetFullyQualifiedRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<System.Collections.Generic.IEnumerable<string>> GetFullyQualifiedAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> GetFullyQualifiedRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		IEnumerable<(string, int, bool)> GetTuple(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage GetTupleRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<IEnumerable<(string, int, bool)>> GetTupleAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> GetTupleRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		[ObsoleteAttribute("Testing Obsolete")]
		IDictionary<string, IEnumerable<Tuple<string, int, bool, char>>> GetNestedTypes(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		[ObsoleteAttribute("Testing Obsolete")]
		HttpResponseMessage GetNestedTypesRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		[ObsoleteAttribute("Testing Obsolete")]
		ValueTask<IDictionary<string, IEnumerable<Tuple<string, int, bool, char>>>> GetNestedTypesAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		[ObsoleteAttribute("Testing Obsolete")]
		ValueTask<HttpResponseMessage> GetNestedTypesRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		string Get(int id, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage GetRaw(int id, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<string> GetAsync(int id, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> GetRawAsync(int id, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void Post(string value, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage PostRaw(string value, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task PostAsync(string value, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> PostRawAsync(string value, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void Put(string value, int id, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage PutRaw(string value, int id, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task PutAsync(string value, int id, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> PutRawAsync(string value, int id, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		bool Delete(int id, int ControllerHeader = 0, SecurityHeader auth = null, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action UnauthorizedCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage DeleteRaw(int id, int ControllerHeader = 0, SecurityHeader auth = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<bool> DeleteAsync(int id, int ControllerHeader = 0, SecurityHeader auth = null, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action UnauthorizedCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> DeleteRawAsync(int id, int ControllerHeader = 0, SecurityHeader auth = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void ActionRoute(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage ActionRouteRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task ActionRouteAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> ActionRouteRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		bool TestPreFunc(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage TestPreFuncRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<bool> TestPreFuncAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> TestPreFuncRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void CancellationTestEndpoint(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage CancellationTestEndpointRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task CancellationTestEndpointAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> CancellationTestEndpointRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void NullableParameterOrdering(int id, int? TestId, bool deleted = false, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage NullableParameterOrderingRaw(int id, int? TestId, bool deleted = false, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task NullableParameterOrderingAsync(int id, int? TestId, bool deleted = false, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> NullableParameterOrderingRawAsync(int id, int? TestId, bool deleted = false, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		string HeaderTestString(String SpecialValue1, string SpecialValue2, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage HeaderTestStringRaw(String SpecialValue1, string SpecialValue2, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<string> HeaderTestStringAsync(String SpecialValue1, string SpecialValue2, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> HeaderTestStringRawAsync(String SpecialValue1, string SpecialValue2, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		int HeaderTestInt(int SpecialValue1, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage HeaderTestIntRaw(int SpecialValue1, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<int> HeaderTestIntAsync(int SpecialValue1, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> HeaderTestIntRawAsync(int SpecialValue1, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void FancyDtoReturn(int id, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<MyFancyDto> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage FancyDtoReturnRaw(int id, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task FancyDtoReturnAsync(int id, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<MyFancyDto> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> FancyDtoReturnRawAsync(int id, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void TaskReturn(MyFancyDto dto, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage TaskReturnRaw(MyFancyDto dto, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task TaskReturnAsync(MyFancyDto dto, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> TaskReturnRawAsync(MyFancyDto dto, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		MyFancyDto DtoForDto(MyFancyDto dto, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage DtoForDtoRaw(MyFancyDto dto, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<MyFancyDto> DtoForDtoAsync(MyFancyDto dto, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> DtoForDtoRawAsync(MyFancyDto dto, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void GuidReturn(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<Guid> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage GuidReturnRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task GuidReturnAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<Guid> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> GuidReturnRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void DateTimeReturns(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<DateTime> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage DateTimeReturnsRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task DateTimeReturnsAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<DateTime> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> DateTimeReturnsRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void BoolReturns(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<bool> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage BoolReturnsRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task BoolReturnsAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<bool> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> BoolReturnsRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void PostWithNoBody(Guid id, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage PostWithNoBodyRaw(Guid id, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task PostWithNoBodyAsync(Guid id, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> PostWithNoBodyRawAsync(Guid id, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void ComplexPost(MyFancyDto dto, Guid testId, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<MyFancyDto> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage ComplexPostRaw(MyFancyDto dto, Guid testId, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task ComplexPostAsync(MyFancyDto dto, Guid testId, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<MyFancyDto> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> ComplexPostRawAsync(MyFancyDto dto, Guid testId, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void PostWithSimpleBody(Guid id, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<Guid> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage PostWithSimpleBodyRaw(Guid id, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task PostWithSimpleBodyAsync(Guid id, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<Guid> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> PostWithSimpleBodyRawAsync(Guid id, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void EnumerableGet(IEnumerable<int> ids, IEnumerable<bool> truth, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<IEnumerable<int>> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage EnumerableGetRaw(IEnumerable<int> ids, IEnumerable<bool> truth, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task EnumerableGetAsync(IEnumerable<int> ids, IEnumerable<bool> truth, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<IEnumerable<int>> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> EnumerableGetRawAsync(IEnumerable<int> ids, IEnumerable<bool> truth, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void EnumerableGetCustom(IEnumerable<int> customIds, IEnumerable<bool> truth, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<IEnumerable<int>> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage EnumerableGetCustomRaw(IEnumerable<int> customIds, IEnumerable<bool> truth, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task EnumerableGetCustomAsync(IEnumerable<int> customIds, IEnumerable<bool> truth, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<IEnumerable<int>> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> EnumerableGetCustomRawAsync(IEnumerable<int> customIds, IEnumerable<bool> truth, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void AttributeFormatting(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<IEnumerable<int>> OKCallback = null, Action<int> NoContentCallback = null, Action<int> SeeOtherCallback = null, Action<string> NotModifiedCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage AttributeFormattingRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task AttributeFormattingAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<IEnumerable<int>> OKCallback = null, Action<int> NoContentCallback = null, Action<int> SeeOtherCallback = null, Action<string> NotModifiedCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> AttributeFormattingRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void QueryParameter(string name, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<string> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage QueryParameterRaw(string name, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task QueryParameterAsync(string name, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<string> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> QueryParameterRawAsync(string name, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		System.IO.Stream FileReturn(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage FileReturnRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<System.IO.Stream> FileReturnAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> FileReturnRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void FileReturnResponseTypes(bool pass, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<Stream> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage FileReturnResponseTypesRaw(bool pass, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task FileReturnResponseTypesAsync(bool pass, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<Stream> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> FileReturnResponseTypesRawAsync(bool pass, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		int? DefaultRouteConstraint(int? x = 5, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage DefaultRouteConstraintRaw(int? x = 5, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<int? > DefaultRouteConstraintAsync(int? x = 5, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> DefaultRouteConstraintRawAsync(int? x = 5, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		int? OptionalRouteConstraint(int? x, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage OptionalRouteConstraintRaw(int? x, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<int? > OptionalRouteConstraintAsync(int? x, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> OptionalRouteConstraintRawAsync(int? x, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		DateTime CheckDateTime(DateTime date, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage CheckDateTimeRaw(DateTime date, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<DateTime> CheckDateTimeAsync(DateTime date, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> CheckDateTimeRawAsync(DateTime date, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		DateTime CheckDateTimeNullable(DateTime? date, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage CheckDateTimeNullableRaw(DateTime? date, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<DateTime> CheckDateTimeNullableAsync(DateTime? date, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> CheckDateTimeNullableRawAsync(DateTime? date, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		DateTimeOffset CheckDateTimeOffset(DateTimeOffset date, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage CheckDateTimeOffsetRaw(DateTimeOffset date, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<DateTimeOffset> CheckDateTimeOffsetAsync(DateTimeOffset date, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> CheckDateTimeOffsetRawAsync(DateTimeOffset date, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		DateTimeOffset CheckDateTimeOffsetNullable(DateTimeOffset? date, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage CheckDateTimeOffsetNullableRaw(DateTimeOffset? date, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<DateTimeOffset> CheckDateTimeOffsetNullableAsync(DateTimeOffset? date, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> CheckDateTimeOffsetNullableRawAsync(DateTimeOffset? date, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void RouteConstraintCheck(string name, int id, bool val, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage RouteConstraintCheckRaw(string name, int id, bool val, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task RouteConstraintCheckAsync(string name, int id, bool val, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> RouteConstraintCheckRawAsync(string name, int id, bool val, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		MyFancyDto DuplicateMethodReturnAndResponse(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage DuplicateMethodReturnAndResponseRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<MyFancyDto> DuplicateMethodReturnAndResponseAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> DuplicateMethodReturnAndResponseRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void ProblemDetailsRequest(RequiredDto dto, int ControllerHeader = 0, Action<ValidationProblemDetails> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage ProblemDetailsRequestRaw(RequiredDto dto, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task ProblemDetailsRequestAsync(RequiredDto dto, int ControllerHeader = 0, Action<ValidationProblemDetails> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> ProblemDetailsRequestRawAsync(RequiredDto dto, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void ModelStateBadRequest(int ControllerHeader = 0, Action<IReadOnlyDictionary<string, IEnumerable<string>>> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage ModelStateBadRequestRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task ModelStateBadRequestAsync(int ControllerHeader = 0, Action<IReadOnlyDictionary<string, IEnumerable<string>>> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> ModelStateBadRequestRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void UrlEncodingCheck(string code, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<string> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage UrlEncodingCheckRaw(string code, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task UrlEncodingCheckAsync(string code, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<string> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> UrlEncodingCheckRawAsync(string code, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		void UrlEncodingQueryCheck(string code, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<string> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage UrlEncodingQueryCheckRaw(string code, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task UrlEncodingQueryCheckAsync(string code, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<string> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> UrlEncodingQueryCheckRawAsync(string code, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
	}

	internal class ValuesClient : IValuesClient
	{
		protected readonly ITestWebAppClientWrapper Client;
		protected readonly IHttpOverride HttpOverride;
		protected readonly IHttpSerializer Serializer;
		protected readonly IHttpRequestModifier Modifier;
		public ValuesClient(ITestWebAppClientWrapper param_client, Func<ITestWebAppClient, IHttpOverride> param_httpoverride, Func<ITestWebAppClient, IHttpSerializer> param_serializer, Func<ITestWebAppClient, IHttpRequestModifier> param_modifier)
		{
			Client = param_client;
			HttpOverride = param_httpoverride(this);
			Serializer = param_serializer(this);
			Modifier = param_modifier(this);
		}

		public IEnumerable<string> GetEnumerable(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(IEnumerable<string>);
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<IEnumerable<string>>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(IEnumerable<string>);
			}
		}

		public HttpResponseMessage GetEnumerableRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async ValueTask<IEnumerable<string>> GetEnumerableAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(IEnumerable<string>);
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<IEnumerable<string>>(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(IEnumerable<string>);
			}
		}

		public async ValueTask<HttpResponseMessage> GetEnumerableRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public IEnumerable<string> GetEnumerableTask(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/getAsync";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(IEnumerable<string>);
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<IEnumerable<string>>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(IEnumerable<string>);
			}
		}

		public HttpResponseMessage GetEnumerableTaskRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/getAsync";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async ValueTask<IEnumerable<string>> GetEnumerableTaskAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/getAsync";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(IEnumerable<string>);
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<IEnumerable<string>>(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(IEnumerable<string>);
			}
		}

		public async ValueTask<HttpResponseMessage> GetEnumerableTaskRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/getAsync";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public System.Collections.Generic.IEnumerable<string> GetFullyQualified(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/getQualified";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(System.Collections.Generic.IEnumerable<string>);
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<System.Collections.Generic.IEnumerable<string>>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(System.Collections.Generic.IEnumerable<string>);
			}
		}

		public HttpResponseMessage GetFullyQualifiedRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/getQualified";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async ValueTask<System.Collections.Generic.IEnumerable<string>> GetFullyQualifiedAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/getQualified";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(System.Collections.Generic.IEnumerable<string>);
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<System.Collections.Generic.IEnumerable<string>>(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(System.Collections.Generic.IEnumerable<string>);
			}
		}

		public async ValueTask<HttpResponseMessage> GetFullyQualifiedRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/getQualified";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public IEnumerable<(string, int, bool)> GetTuple(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/getTuple";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(IEnumerable<(string, int, bool)>);
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<IEnumerable<(string, int, bool)>>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(IEnumerable<(string, int, bool)>);
			}
		}

		public HttpResponseMessage GetTupleRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/getTuple";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async ValueTask<IEnumerable<(string, int, bool)>> GetTupleAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/getTuple";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(IEnumerable<(string, int, bool)>);
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<IEnumerable<(string, int, bool)>>(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(IEnumerable<(string, int, bool)>);
			}
		}

		public async ValueTask<HttpResponseMessage> GetTupleRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/getTuple";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		[ObsoleteAttribute("Testing Obsolete")]
		public IDictionary<string, IEnumerable<Tuple<string, int, bool, char>>> GetNestedTypes(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/getNested";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(IDictionary<string, IEnumerable<Tuple<string, int, bool, char>>>);
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<IDictionary<string, IEnumerable<Tuple<string, int, bool, char>>>>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(IDictionary<string, IEnumerable<Tuple<string, int, bool, char>>>);
			}
		}

		[ObsoleteAttribute("Testing Obsolete")]
		public HttpResponseMessage GetNestedTypesRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/getNested";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		[ObsoleteAttribute("Testing Obsolete")]
		public async ValueTask<IDictionary<string, IEnumerable<Tuple<string, int, bool, char>>>> GetNestedTypesAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/getNested";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(IDictionary<string, IEnumerable<Tuple<string, int, bool, char>>>);
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<IDictionary<string, IEnumerable<Tuple<string, int, bool, char>>>>(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(IDictionary<string, IEnumerable<Tuple<string, int, bool, char>>>);
			}
		}

		[ObsoleteAttribute("Testing Obsolete")]
		public async ValueTask<HttpResponseMessage> GetNestedTypesRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/getNested";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public string Get(int id, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithHeader("GEEET", "FULL").WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(string);
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(string);
			}
		}

		public HttpResponseMessage GetRaw(int id, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithHeader("GEEET", "FULL").WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async ValueTask<string> GetAsync(int id, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithHeader("GEEET", "FULL").WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(string);
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(string);
			}
		}

		public async ValueTask<HttpResponseMessage> GetRawAsync(int id, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithHeader("GEEET", "FULL").WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void Post(string value, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(value), cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, value, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage PostRaw(string value, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(value), cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, value, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task PostAsync(string value, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(value), cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, value, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> PostRawAsync(string value, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(value), cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, value, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void Put(string value, int id, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Put, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PutAsync(Serializer.Serialize(value), cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Put, url, value, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage PutRaw(string value, int id, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Put, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PutAsync(Serializer.Serialize(value), cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Put, url, value, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task PutAsync(string value, int id, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Put, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PutAsync(Serializer.Serialize(value), cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Put, url, value, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> PutRawAsync(string value, int id, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Put, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PutAsync(Serializer.Serialize(value), cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Put, url, value, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public bool Delete(int id, int ControllerHeader = 0, SecurityHeader auth = null, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action UnauthorizedCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Delete, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).WithAuth(auth).AllowAnyHttpStatus().DeleteAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(bool);
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Delete, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (UnauthorizedCallback != null && UnauthorizedCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for UnauthorizedCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.Unauthorized)
			{
				if (UnauthorizedCallback != null)
				{
					responseHandled = true;
					UnauthorizedCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<bool>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(bool);
			}
		}

		public HttpResponseMessage DeleteRaw(int id, int ControllerHeader = 0, SecurityHeader auth = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Delete, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).WithAuth(auth).AllowAnyHttpStatus().DeleteAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Delete, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async ValueTask<bool> DeleteAsync(int id, int ControllerHeader = 0, SecurityHeader auth = null, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action UnauthorizedCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Delete, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).WithAuth(auth).AllowAnyHttpStatus().DeleteAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(bool);
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Delete, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (UnauthorizedCallback != null && UnauthorizedCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for UnauthorizedCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.Unauthorized)
			{
				if (UnauthorizedCallback != null)
				{
					responseHandled = true;
					UnauthorizedCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<bool>(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(bool);
			}
		}

		public async ValueTask<HttpResponseMessage> DeleteRawAsync(int id, int ControllerHeader = 0, SecurityHeader auth = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			string url = $@"api/{controller}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Delete, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).WithAuth(auth).AllowAnyHttpStatus().DeleteAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Delete, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void ActionRoute(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "ActionRouteAsync";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage ActionRouteRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "ActionRouteAsync";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task ActionRouteAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "ActionRouteAsync";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> ActionRouteRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "ActionRouteAsync";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public bool TestPreFunc(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "TestPreFunc";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(bool);
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<bool>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(bool);
			}
		}

		public HttpResponseMessage TestPreFuncRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "TestPreFunc";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async ValueTask<bool> TestPreFuncAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "TestPreFunc";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(bool);
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<bool>(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(bool);
			}
		}

		public async ValueTask<HttpResponseMessage> TestPreFuncRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "TestPreFunc";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void CancellationTestEndpoint(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "CancellationTestEndpoint";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage CancellationTestEndpointRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "CancellationTestEndpoint";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task CancellationTestEndpointAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "CancellationTestEndpoint";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> CancellationTestEndpointRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "CancellationTestEndpoint";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void NullableParameterOrdering(int id, int? TestId, bool deleted = false, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!int.TryParse(id.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter id does not parse into an int.");
			}

			var controller = "Values";
			var action = "NullableParameterOrdering";
			string url = $@"api/{controller}/{action}/{id.EncodeForUrl()}?{nameof(deleted)}={deleted.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).WithHeader("TestId", TestId).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage NullableParameterOrderingRaw(int id, int? TestId, bool deleted = false, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!int.TryParse(id.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter id does not parse into an int.");
			}

			var controller = "Values";
			var action = "NullableParameterOrdering";
			string url = $@"api/{controller}/{action}/{id.EncodeForUrl()}?{nameof(deleted)}={deleted.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).WithHeader("TestId", TestId).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task NullableParameterOrderingAsync(int id, int? TestId, bool deleted = false, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!int.TryParse(id.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter id does not parse into an int.");
			}

			var controller = "Values";
			var action = "NullableParameterOrdering";
			string url = $@"api/{controller}/{action}/{id.EncodeForUrl()}?{nameof(deleted)}={deleted.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).WithHeader("TestId", TestId).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> NullableParameterOrderingRawAsync(int id, int? TestId, bool deleted = false, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!int.TryParse(id.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter id does not parse into an int.");
			}

			var controller = "Values";
			var action = "NullableParameterOrdering";
			string url = $@"api/{controller}/{action}/{id.EncodeForUrl()}?{nameof(deleted)}={deleted.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).WithHeader("TestId", TestId).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public string HeaderTestString(String SpecialValue1, string SpecialValue2, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "HeaderTestString";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).WithHeader("SpecialValue1", SpecialValue1).WithHeader("SpecialValue2", SpecialValue2).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(string);
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(string);
			}
		}

		public HttpResponseMessage HeaderTestStringRaw(String SpecialValue1, string SpecialValue2, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "HeaderTestString";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).WithHeader("SpecialValue1", SpecialValue1).WithHeader("SpecialValue2", SpecialValue2).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async ValueTask<string> HeaderTestStringAsync(String SpecialValue1, string SpecialValue2, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "HeaderTestString";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).WithHeader("SpecialValue1", SpecialValue1).WithHeader("SpecialValue2", SpecialValue2).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(string);
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(string);
			}
		}

		public async ValueTask<HttpResponseMessage> HeaderTestStringRawAsync(String SpecialValue1, string SpecialValue2, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "HeaderTestString";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).WithHeader("SpecialValue1", SpecialValue1).WithHeader("SpecialValue2", SpecialValue2).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public int HeaderTestInt(int SpecialValue1, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "HeaderTestInt";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).WithHeader("SpecialValue1", SpecialValue1).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(int);
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<int>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(int);
			}
		}

		public HttpResponseMessage HeaderTestIntRaw(int SpecialValue1, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "HeaderTestInt";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).WithHeader("SpecialValue1", SpecialValue1).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async ValueTask<int> HeaderTestIntAsync(int SpecialValue1, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "HeaderTestInt";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).WithHeader("SpecialValue1", SpecialValue1).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(int);
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<int>(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(int);
			}
		}

		public async ValueTask<HttpResponseMessage> HeaderTestIntRawAsync(int SpecialValue1, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "HeaderTestInt";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).WithHeader("SpecialValue1", SpecialValue1).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void FancyDtoReturn(int id, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<MyFancyDto> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!int.TryParse(id.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter id does not parse into an int.");
			}

			var controller = "Values";
			var action = "FancyDtoReturn";
			string url = $@"api/{controller}/{action}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(Serializer.Deserialize<MyFancyDto>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage FancyDtoReturnRaw(int id, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!int.TryParse(id.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter id does not parse into an int.");
			}

			var controller = "Values";
			var action = "FancyDtoReturn";
			string url = $@"api/{controller}/{action}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task FancyDtoReturnAsync(int id, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<MyFancyDto> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!int.TryParse(id.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter id does not parse into an int.");
			}

			var controller = "Values";
			var action = "FancyDtoReturn";
			string url = $@"api/{controller}/{action}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(await Serializer.Deserialize<MyFancyDto>(response.Content).ConfigureAwait(false));
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> FancyDtoReturnRawAsync(int id, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!int.TryParse(id.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter id does not parse into an int.");
			}

			var controller = "Values";
			var action = "FancyDtoReturn";
			string url = $@"api/{controller}/{action}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void TaskReturn(MyFancyDto dto, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "TaskReturn";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(dto), cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage TaskReturnRaw(MyFancyDto dto, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "TaskReturn";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(dto), cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task TaskReturnAsync(MyFancyDto dto, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "TaskReturn";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(dto), cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> TaskReturnRawAsync(MyFancyDto dto, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "TaskReturn";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(dto), cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public MyFancyDto DtoForDto(MyFancyDto dto, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "DtoForDto";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(dto), cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(MyFancyDto);
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<MyFancyDto>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(MyFancyDto);
			}
		}

		public HttpResponseMessage DtoForDtoRaw(MyFancyDto dto, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "DtoForDto";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(dto), cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async ValueTask<MyFancyDto> DtoForDtoAsync(MyFancyDto dto, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "DtoForDto";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(dto), cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(MyFancyDto);
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<MyFancyDto>(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(MyFancyDto);
			}
		}

		public async ValueTask<HttpResponseMessage> DtoForDtoRawAsync(MyFancyDto dto, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "DtoForDto";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(dto), cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void GuidReturn(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<Guid> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "GuidReturn";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(Serializer.Deserialize<Guid>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage GuidReturnRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "GuidReturn";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task GuidReturnAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<Guid> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "GuidReturn";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(await Serializer.Deserialize<Guid>(response.Content).ConfigureAwait(false));
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> GuidReturnRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "GuidReturn";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void DateTimeReturns(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<DateTime> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "DateTimeReturns";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(Serializer.Deserialize<DateTime>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage DateTimeReturnsRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "DateTimeReturns";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task DateTimeReturnsAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<DateTime> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "DateTimeReturns";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(await Serializer.Deserialize<DateTime>(response.Content).ConfigureAwait(false));
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> DateTimeReturnsRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "DateTimeReturns";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void BoolReturns(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<bool> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "BoolReturns";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(Serializer.Deserialize<bool>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage BoolReturnsRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "BoolReturns";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task BoolReturnsAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<bool> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "BoolReturns";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(await Serializer.Deserialize<bool>(response.Content).ConfigureAwait(false));
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> BoolReturnsRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "BoolReturns";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void PostWithNoBody(Guid id, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!Guid.TryParse(id.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter id does not parse into an Guid.");
			}

			var controller = "Values";
			var action = "PostWithNoBody";
			string url = $@"api/{controller}/{action}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage PostWithNoBodyRaw(Guid id, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!Guid.TryParse(id.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter id does not parse into an Guid.");
			}

			var controller = "Values";
			var action = "PostWithNoBody";
			string url = $@"api/{controller}/{action}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task PostWithNoBodyAsync(Guid id, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!Guid.TryParse(id.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter id does not parse into an Guid.");
			}

			var controller = "Values";
			var action = "PostWithNoBody";
			string url = $@"api/{controller}/{action}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(null, cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> PostWithNoBodyRawAsync(Guid id, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!Guid.TryParse(id.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter id does not parse into an Guid.");
			}

			var controller = "Values";
			var action = "PostWithNoBody";
			string url = $@"api/{controller}/{action}/{id.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(null, cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void ComplexPost(MyFancyDto dto, Guid testId, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<MyFancyDto> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!Guid.TryParse(testId.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter testId does not parse into an Guid.");
			}

			var controller = "Values";
			var action = "ComplexPost";
			string url = $@"api/{controller}/{action}/{testId.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(dto), cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(Serializer.Deserialize<MyFancyDto>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage ComplexPostRaw(MyFancyDto dto, Guid testId, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!Guid.TryParse(testId.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter testId does not parse into an Guid.");
			}

			var controller = "Values";
			var action = "ComplexPost";
			string url = $@"api/{controller}/{action}/{testId.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(dto), cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task ComplexPostAsync(MyFancyDto dto, Guid testId, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<MyFancyDto> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!Guid.TryParse(testId.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter testId does not parse into an Guid.");
			}

			var controller = "Values";
			var action = "ComplexPost";
			string url = $@"api/{controller}/{action}/{testId.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(dto), cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(await Serializer.Deserialize<MyFancyDto>(response.Content).ConfigureAwait(false));
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> ComplexPostRawAsync(MyFancyDto dto, Guid testId, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!Guid.TryParse(testId.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter testId does not parse into an Guid.");
			}

			var controller = "Values";
			var action = "ComplexPost";
			string url = $@"api/{controller}/{action}/{testId.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(dto), cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void PostWithSimpleBody(Guid id, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<Guid> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "PostWithSimpleBody";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(id), cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, id, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(Serializer.Deserialize<Guid>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage PostWithSimpleBodyRaw(Guid id, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "PostWithSimpleBody";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(id), cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, id, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task PostWithSimpleBodyAsync(Guid id, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<Guid> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "PostWithSimpleBody";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(id), cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, id, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(await Serializer.Deserialize<Guid>(response.Content).ConfigureAwait(false));
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> PostWithSimpleBodyRawAsync(Guid id, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "PostWithSimpleBody";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(id), cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, id, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void EnumerableGet(IEnumerable<int> ids, IEnumerable<bool> truth, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<IEnumerable<int>> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "EnumerableGet";
			string url = $@"api/{controller}/{action}?{string.Join("&", ids.Select(x => $"{nameof(ids)}={x.EncodeForUrl()}"))}&{string.Join("&", truth.Select(x => $"{nameof(truth)}={x.EncodeForUrl()}"))}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(Serializer.Deserialize<IEnumerable<int>>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage EnumerableGetRaw(IEnumerable<int> ids, IEnumerable<bool> truth, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "EnumerableGet";
			string url = $@"api/{controller}/{action}?{string.Join("&", ids.Select(x => $"{nameof(ids)}={x.EncodeForUrl()}"))}&{string.Join("&", truth.Select(x => $"{nameof(truth)}={x.EncodeForUrl()}"))}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task EnumerableGetAsync(IEnumerable<int> ids, IEnumerable<bool> truth, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<IEnumerable<int>> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "EnumerableGet";
			string url = $@"api/{controller}/{action}?{string.Join("&", ids.Select(x => $"{nameof(ids)}={x.EncodeForUrl()}"))}&{string.Join("&", truth.Select(x => $"{nameof(truth)}={x.EncodeForUrl()}"))}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(await Serializer.Deserialize<IEnumerable<int>>(response.Content).ConfigureAwait(false));
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> EnumerableGetRawAsync(IEnumerable<int> ids, IEnumerable<bool> truth, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "EnumerableGet";
			string url = $@"api/{controller}/{action}?{string.Join("&", ids.Select(x => $"{nameof(ids)}={x.EncodeForUrl()}"))}&{string.Join("&", truth.Select(x => $"{nameof(truth)}={x.EncodeForUrl()}"))}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void EnumerableGetCustom(IEnumerable<int> customIds, IEnumerable<bool> truth, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<IEnumerable<int>> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "EnumerableGetCustom";
			string url = $@"api/{controller}/{action}?{string.Join("&", customIds.Select(x => $"{nameof(customIds)}={x.EncodeForUrl()}"))}&{string.Join("&", truth.Select(x => $"{nameof(truth)}={x.EncodeForUrl()}"))}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(Serializer.Deserialize<IEnumerable<int>>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage EnumerableGetCustomRaw(IEnumerable<int> customIds, IEnumerable<bool> truth, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "EnumerableGetCustom";
			string url = $@"api/{controller}/{action}?{string.Join("&", customIds.Select(x => $"{nameof(customIds)}={x.EncodeForUrl()}"))}&{string.Join("&", truth.Select(x => $"{nameof(truth)}={x.EncodeForUrl()}"))}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task EnumerableGetCustomAsync(IEnumerable<int> customIds, IEnumerable<bool> truth, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<IEnumerable<int>> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "EnumerableGetCustom";
			string url = $@"api/{controller}/{action}?{string.Join("&", customIds.Select(x => $"{nameof(customIds)}={x.EncodeForUrl()}"))}&{string.Join("&", truth.Select(x => $"{nameof(truth)}={x.EncodeForUrl()}"))}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(await Serializer.Deserialize<IEnumerable<int>>(response.Content).ConfigureAwait(false));
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> EnumerableGetCustomRawAsync(IEnumerable<int> customIds, IEnumerable<bool> truth, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "EnumerableGetCustom";
			string url = $@"api/{controller}/{action}?{string.Join("&", customIds.Select(x => $"{nameof(customIds)}={x.EncodeForUrl()}"))}&{string.Join("&", truth.Select(x => $"{nameof(truth)}={x.EncodeForUrl()}"))}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void AttributeFormatting(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<IEnumerable<int>> OKCallback = null, Action<int> NoContentCallback = null, Action<int> SeeOtherCallback = null, Action<string> NotModifiedCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "AttributeFormatting";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(Serializer.Deserialize<IEnumerable<int>>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (NoContentCallback != null && NoContentCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for NoContentCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.NoContent)
			{
				if (NoContentCallback != null)
				{
					responseHandled = true;
					NoContentCallback.Invoke(Serializer.Deserialize<int>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (SeeOtherCallback != null && SeeOtherCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for SeeOtherCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.SeeOther)
			{
				if (SeeOtherCallback != null)
				{
					responseHandled = true;
					SeeOtherCallback.Invoke(Serializer.Deserialize<int>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (NotModifiedCallback != null && NotModifiedCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for NotModifiedCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.NotModified)
			{
				if (NotModifiedCallback != null)
				{
					responseHandled = true;
					NotModifiedCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage AttributeFormattingRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "AttributeFormatting";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task AttributeFormattingAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<IEnumerable<int>> OKCallback = null, Action<int> NoContentCallback = null, Action<int> SeeOtherCallback = null, Action<string> NotModifiedCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "AttributeFormatting";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(await Serializer.Deserialize<IEnumerable<int>>(response.Content).ConfigureAwait(false));
				}
			}

			if (NoContentCallback != null && NoContentCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for NoContentCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.NoContent)
			{
				if (NoContentCallback != null)
				{
					responseHandled = true;
					NoContentCallback.Invoke(await Serializer.Deserialize<int>(response.Content).ConfigureAwait(false));
				}
			}

			if (SeeOtherCallback != null && SeeOtherCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for SeeOtherCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.SeeOther)
			{
				if (SeeOtherCallback != null)
				{
					responseHandled = true;
					SeeOtherCallback.Invoke(await Serializer.Deserialize<int>(response.Content).ConfigureAwait(false));
				}
			}

			if (NotModifiedCallback != null && NotModifiedCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for NotModifiedCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.NotModified)
			{
				if (NotModifiedCallback != null)
				{
					responseHandled = true;
					NotModifiedCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> AttributeFormattingRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "AttributeFormatting";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void QueryParameter(string name, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<string> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "QueryParameter";
			string url = $@"api/{controller}/{action}?{nameof(name)}={name.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage QueryParameterRaw(string name, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "QueryParameter";
			string url = $@"api/{controller}/{action}?{nameof(name)}={name.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task QueryParameterAsync(string name, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<string> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "QueryParameter";
			string url = $@"api/{controller}/{action}?{nameof(name)}={name.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> QueryParameterRawAsync(string name, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "QueryParameter";
			string url = $@"api/{controller}/{action}?{nameof(name)}={name.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public System.IO.Stream FileReturn(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "FileReturn";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(System.IO.Stream);
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return response.Content.ReadAsStreamAsync().ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(System.IO.Stream);
			}
		}

		public HttpResponseMessage FileReturnRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "FileReturn";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async ValueTask<System.IO.Stream> FileReturnAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "FileReturn";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(System.IO.Stream);
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return await response.Content.ReadAsStreamAsync().ConfigureAwait(false);
			}
			else
			{
				return default(System.IO.Stream);
			}
		}

		public async ValueTask<HttpResponseMessage> FileReturnRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "FileReturn";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void FileReturnResponseTypes(bool pass, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<Stream> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "FileReturnResponseTypes";
			string url = $@"api/{controller}/{action}?{nameof(pass)}={pass.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(response.Content.ReadAsStreamAsync().ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage FileReturnResponseTypesRaw(bool pass, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "FileReturnResponseTypes";
			string url = $@"api/{controller}/{action}?{nameof(pass)}={pass.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task FileReturnResponseTypesAsync(bool pass, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<Stream> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "FileReturnResponseTypes";
			string url = $@"api/{controller}/{action}?{nameof(pass)}={pass.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(await response.Content.ReadAsStreamAsync().ConfigureAwait(false));
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> FileReturnResponseTypesRawAsync(bool pass, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "FileReturnResponseTypes";
			string url = $@"api/{controller}/{action}?{nameof(pass)}={pass.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public int? DefaultRouteConstraint(int? x = 5, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "DefaultRouteConstraint";
			string url = $@"api/{controller}/{action}/defaultConstraint/{x.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(int? );
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<int? >(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(int? );
			}
		}

		public HttpResponseMessage DefaultRouteConstraintRaw(int? x = 5, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "DefaultRouteConstraint";
			string url = $@"api/{controller}/{action}/defaultConstraint/{x.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async ValueTask<int? > DefaultRouteConstraintAsync(int? x = 5, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "DefaultRouteConstraint";
			string url = $@"api/{controller}/{action}/defaultConstraint/{x.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(int? );
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<int? >(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(int? );
			}
		}

		public async ValueTask<HttpResponseMessage> DefaultRouteConstraintRawAsync(int? x = 5, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "DefaultRouteConstraint";
			string url = $@"api/{controller}/{action}/defaultConstraint/{x.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public int? OptionalRouteConstraint(int? x, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "OptionalRouteConstraint";
			string url = $@"api/{controller}/{action}/optional/{x.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(int? );
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<int? >(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(int? );
			}
		}

		public HttpResponseMessage OptionalRouteConstraintRaw(int? x, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "OptionalRouteConstraint";
			string url = $@"api/{controller}/{action}/optional/{x.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async ValueTask<int? > OptionalRouteConstraintAsync(int? x, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "OptionalRouteConstraint";
			string url = $@"api/{controller}/{action}/optional/{x.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(int? );
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<int? >(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(int? );
			}
		}

		public async ValueTask<HttpResponseMessage> OptionalRouteConstraintRawAsync(int? x, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "OptionalRouteConstraint";
			string url = $@"api/{controller}/{action}/optional/{x.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public DateTime CheckDateTime(DateTime date, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "CheckDateTime";
			string url = $@"api/{controller}/{action}/checkDate/{date.ToString("s", System.Globalization.CultureInfo.InvariantCulture).EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(DateTime);
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<DateTime>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(DateTime);
			}
		}

		public HttpResponseMessage CheckDateTimeRaw(DateTime date, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "CheckDateTime";
			string url = $@"api/{controller}/{action}/checkDate/{date.ToString("s", System.Globalization.CultureInfo.InvariantCulture).EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async ValueTask<DateTime> CheckDateTimeAsync(DateTime date, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "CheckDateTime";
			string url = $@"api/{controller}/{action}/checkDate/{date.ToString("s", System.Globalization.CultureInfo.InvariantCulture).EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(DateTime);
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<DateTime>(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(DateTime);
			}
		}

		public async ValueTask<HttpResponseMessage> CheckDateTimeRawAsync(DateTime date, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "CheckDateTime";
			string url = $@"api/{controller}/{action}/checkDate/{date.ToString("s", System.Globalization.CultureInfo.InvariantCulture).EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public DateTime CheckDateTimeNullable(DateTime? date, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "CheckDateTimeNullable";
			string url = $@"api/{controller}/{action}/checkDate/{date?.ToString("s", System.Globalization.CultureInfo.InvariantCulture).EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(DateTime);
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<DateTime>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(DateTime);
			}
		}

		public HttpResponseMessage CheckDateTimeNullableRaw(DateTime? date, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "CheckDateTimeNullable";
			string url = $@"api/{controller}/{action}/checkDate/{date?.ToString("s", System.Globalization.CultureInfo.InvariantCulture).EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async ValueTask<DateTime> CheckDateTimeNullableAsync(DateTime? date, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "CheckDateTimeNullable";
			string url = $@"api/{controller}/{action}/checkDate/{date?.ToString("s", System.Globalization.CultureInfo.InvariantCulture).EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(DateTime);
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<DateTime>(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(DateTime);
			}
		}

		public async ValueTask<HttpResponseMessage> CheckDateTimeNullableRawAsync(DateTime? date, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "CheckDateTimeNullable";
			string url = $@"api/{controller}/{action}/checkDate/{date?.ToString("s", System.Globalization.CultureInfo.InvariantCulture).EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public DateTimeOffset CheckDateTimeOffset(DateTimeOffset date, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "CheckDateTimeOffset";
			string url = $@"api/{controller}/{action}/checkDateOffset/{date.ToString("s", System.Globalization.CultureInfo.InvariantCulture).EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(DateTimeOffset);
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<DateTimeOffset>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(DateTimeOffset);
			}
		}

		public HttpResponseMessage CheckDateTimeOffsetRaw(DateTimeOffset date, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "CheckDateTimeOffset";
			string url = $@"api/{controller}/{action}/checkDateOffset/{date.ToString("s", System.Globalization.CultureInfo.InvariantCulture).EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async ValueTask<DateTimeOffset> CheckDateTimeOffsetAsync(DateTimeOffset date, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "CheckDateTimeOffset";
			string url = $@"api/{controller}/{action}/checkDateOffset/{date.ToString("s", System.Globalization.CultureInfo.InvariantCulture).EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(DateTimeOffset);
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<DateTimeOffset>(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(DateTimeOffset);
			}
		}

		public async ValueTask<HttpResponseMessage> CheckDateTimeOffsetRawAsync(DateTimeOffset date, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "CheckDateTimeOffset";
			string url = $@"api/{controller}/{action}/checkDateOffset/{date.ToString("s", System.Globalization.CultureInfo.InvariantCulture).EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public DateTimeOffset CheckDateTimeOffsetNullable(DateTimeOffset? date, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "CheckDateTimeOffsetNullable";
			string url = $@"api/{controller}/{action}/checkDateOffset/{date?.ToString("s", System.Globalization.CultureInfo.InvariantCulture).EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(DateTimeOffset);
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<DateTimeOffset>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(DateTimeOffset);
			}
		}

		public HttpResponseMessage CheckDateTimeOffsetNullableRaw(DateTimeOffset? date, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "CheckDateTimeOffsetNullable";
			string url = $@"api/{controller}/{action}/checkDateOffset/{date?.ToString("s", System.Globalization.CultureInfo.InvariantCulture).EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async ValueTask<DateTimeOffset> CheckDateTimeOffsetNullableAsync(DateTimeOffset? date, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "CheckDateTimeOffsetNullable";
			string url = $@"api/{controller}/{action}/checkDateOffset/{date?.ToString("s", System.Globalization.CultureInfo.InvariantCulture).EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(DateTimeOffset);
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<DateTimeOffset>(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(DateTimeOffset);
			}
		}

		public async ValueTask<HttpResponseMessage> CheckDateTimeOffsetNullableRawAsync(DateTimeOffset? date, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "CheckDateTimeOffsetNullable";
			string url = $@"api/{controller}/{action}/checkDateOffset/{date?.ToString("s", System.Globalization.CultureInfo.InvariantCulture).EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void RouteConstraintCheck(string name, int id, bool val, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!int.TryParse(id.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter id does not parse into an int.");
			}

			var controller = "Values";
			var action = "RouteConstraintCheck";
			string url = $@"api/{controller}/{action}/routeCheck/{name.EncodeForUrl()}/{id.EncodeForUrl()}/{val.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage RouteConstraintCheckRaw(string name, int id, bool val, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!int.TryParse(id.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter id does not parse into an int.");
			}

			var controller = "Values";
			var action = "RouteConstraintCheck";
			string url = $@"api/{controller}/{action}/routeCheck/{name.EncodeForUrl()}/{id.EncodeForUrl()}/{val.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task RouteConstraintCheckAsync(string name, int id, bool val, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!int.TryParse(id.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter id does not parse into an int.");
			}

			var controller = "Values";
			var action = "RouteConstraintCheck";
			string url = $@"api/{controller}/{action}/routeCheck/{name.EncodeForUrl()}/{id.EncodeForUrl()}/{val.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> RouteConstraintCheckRawAsync(string name, int id, bool val, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!int.TryParse(id.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter id does not parse into an int.");
			}

			var controller = "Values";
			var action = "RouteConstraintCheck";
			string url = $@"api/{controller}/{action}/routeCheck/{name.EncodeForUrl()}/{id.EncodeForUrl()}/{val.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public MyFancyDto DuplicateMethodReturnAndResponse(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "DuplicateMethodReturnAndResponse";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(MyFancyDto);
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<MyFancyDto>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(MyFancyDto);
			}
		}

		public HttpResponseMessage DuplicateMethodReturnAndResponseRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "DuplicateMethodReturnAndResponse";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async ValueTask<MyFancyDto> DuplicateMethodReturnAndResponseAsync(int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "DuplicateMethodReturnAndResponse";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(MyFancyDto);
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<MyFancyDto>(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(MyFancyDto);
			}
		}

		public async ValueTask<HttpResponseMessage> DuplicateMethodReturnAndResponseRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "DuplicateMethodReturnAndResponse";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void ProblemDetailsRequest(RequiredDto dto, int ControllerHeader = 0, Action<ValidationProblemDetails> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "ProblemDetailsRequest";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(dto), cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<ValidationProblemDetails>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage ProblemDetailsRequestRaw(RequiredDto dto, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "ProblemDetailsRequest";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(dto), cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task ProblemDetailsRequestAsync(RequiredDto dto, int ControllerHeader = 0, Action<ValidationProblemDetails> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "ProblemDetailsRequest";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(dto), cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<ValidationProblemDetails>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> ProblemDetailsRequestRawAsync(RequiredDto dto, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "ProblemDetailsRequest";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(Serializer.Serialize(dto), cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, dto, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void ModelStateBadRequest(int ControllerHeader = 0, Action<IReadOnlyDictionary<string, IEnumerable<string>>> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "ModelStateBadRequest";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<IReadOnlyDictionary<string, IEnumerable<string>>>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage ModelStateBadRequestRaw(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "ModelStateBadRequest";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task ModelStateBadRequestAsync(int ControllerHeader = 0, Action<IReadOnlyDictionary<string, IEnumerable<string>>> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "ModelStateBadRequest";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<IReadOnlyDictionary<string, IEnumerable<string>>>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> ModelStateBadRequestRawAsync(int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "ModelStateBadRequest";
			string url = $@"api/{controller}/{action}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void UrlEncodingCheck(string code, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<string> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "UrlEncodingCheck";
			string url = $@"api/{controller}/{action}/{code.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage UrlEncodingCheckRaw(string code, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "UrlEncodingCheck";
			string url = $@"api/{controller}/{action}/{code.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task UrlEncodingCheckAsync(string code, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<string> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "UrlEncodingCheck";
			string url = $@"api/{controller}/{action}/{code.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> UrlEncodingCheckRawAsync(string code, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "UrlEncodingCheck";
			string url = $@"api/{controller}/{action}/{code.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}

		public void UrlEncodingQueryCheck(string code, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<string> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "UrlEncodingQueryCheck";
			string url = $@"api/{controller}/{action}?{nameof(code)}={code.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(Serializer.Deserialize<string>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult());
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage UrlEncodingQueryCheckRaw(string code, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "UrlEncodingQueryCheck";
			string url = $@"api/{controller}/{action}?{nameof(code)}={code.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task UrlEncodingQueryCheckAsync(string code, int ControllerHeader = 0, Action<string> BadRequestCallback = null, Action InternalServerErrorCallback = null, Action<string> OKCallback = null, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "UrlEncodingQueryCheck";
			string url = $@"api/{controller}/{action}?{nameof(code)}={code.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (BadRequestCallback != null && BadRequestCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for BadRequestCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
			{
				if (BadRequestCallback != null)
				{
					responseHandled = true;
					BadRequestCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (InternalServerErrorCallback != null && InternalServerErrorCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for InternalServerErrorCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.InternalServerError)
			{
				if (InternalServerErrorCallback != null)
				{
					responseHandled = true;
					InternalServerErrorCallback.Invoke();
				}
			}

			if (OKCallback != null && OKCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for OKCallback are not supported.As they will run out of the scope of this call.");
			}

			if (response.StatusCode == System.Net.HttpStatusCode.OK)
			{
				if (OKCallback != null)
				{
					responseHandled = true;
					OKCallback.Invoke(await Serializer.Deserialize<string>(response.Content).ConfigureAwait(false));
				}
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> UrlEncodingQueryCheckRawAsync(string code, int ControllerHeader = 0, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			var controller = "Values";
			var action = "UrlEncodingQueryCheck";
			string url = $@"api/{controller}/{action}?{nameof(code)}={code.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Get, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithHeader("Test", "EXTRA").WithHeader("ControllerHeader", ControllerHeader).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().GetAsync(cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Get, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}
	}
}

namespace TestWebApp.Clients.V1
{
	public interface ITestClient : ITestWebAppClient
	{
		void Endpoint(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage EndpointRaw(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task EndpointAsync(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> EndpointRawAsync(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
	}

	internal class TestClient : ITestClient
	{
		protected readonly ITestWebAppClientWrapper Client;
		protected readonly IHttpOverride HttpOverride;
		protected readonly IHttpSerializer Serializer;
		protected readonly IHttpRequestModifier Modifier;
		public TestClient(ITestWebAppClientWrapper param_client, Func<ITestWebAppClient, IHttpOverride> param_httpoverride, Func<ITestWebAppClient, IHttpSerializer> param_serializer, Func<ITestWebAppClient, IHttpRequestModifier> param_modifier)
		{
			Client = param_client;
			HttpOverride = param_httpoverride(this);
			Serializer = param_serializer(this);
			Modifier = param_modifier(this);
		}

		public void Endpoint(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			string url = $@"api/v1/test/endpoint";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage EndpointRaw(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			string url = $@"api/v1/test/endpoint";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task EndpointAsync(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			string url = $@"api/v1/test/endpoint";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(null, cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> EndpointRawAsync(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			string url = $@"api/v1/test/endpoint";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(null, cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}
	}
}

namespace TestWebApp.Clients.V2
{
	public interface ITestClient : ITestWebAppClient
	{
		void Endpoint(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage EndpointRaw(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		Task EndpointAsync(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> EndpointRawAsync(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
	}

	internal class TestClient : ITestClient
	{
		protected readonly ITestWebAppClientWrapper Client;
		protected readonly IHttpOverride HttpOverride;
		protected readonly IHttpSerializer Serializer;
		protected readonly IHttpRequestModifier Modifier;
		public TestClient(ITestWebAppClientWrapper param_client, Func<ITestWebAppClient, IHttpOverride> param_httpoverride, Func<ITestWebAppClient, IHttpSerializer> param_serializer, Func<ITestWebAppClient, IHttpRequestModifier> param_modifier)
		{
			Client = param_client;
			HttpOverride = param_httpoverride(this);
			Serializer = param_serializer(this);
			Modifier = param_modifier(this);
		}

		public void Endpoint(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			string url = $@"api/v2/test/endpoint";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public HttpResponseMessage EndpointRaw(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			string url = $@"api/v2/test/endpoint";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async Task EndpointAsync(Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			string url = $@"api/v2/test/endpoint";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(null, cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			return;
		}

		public async ValueTask<HttpResponseMessage> EndpointRawAsync(Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			string url = $@"api/v2/test/endpoint";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(null, cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}
	}
}

namespace TestWebApp.Clients.V3
{
	public interface ITestQueryClient : ITestWebAppClient
	{
		int Endpoint(int index, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage EndpointRaw(int index, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<int> EndpointAsync(int index, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> EndpointRawAsync(int index, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
	}

	internal class TestQueryClient : ITestQueryClient
	{
		protected readonly ITestWebAppClientWrapper Client;
		protected readonly IHttpOverride HttpOverride;
		protected readonly IHttpSerializer Serializer;
		protected readonly IHttpRequestModifier Modifier;
		public TestQueryClient(ITestWebAppClientWrapper param_client, Func<ITestWebAppClient, IHttpOverride> param_httpoverride, Func<ITestWebAppClient, IHttpSerializer> param_serializer, Func<ITestWebAppClient, IHttpRequestModifier> param_modifier)
		{
			Client = param_client;
			HttpOverride = param_httpoverride(this);
			Serializer = param_serializer(this);
			Modifier = param_modifier(this);
		}

		public int Endpoint(int index, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!int.TryParse(index.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter index does not parse into an int.");
			}

			var controller = "TestQuery";
			string url = $@"api/{controller}/endpoint/{index.EncodeForUrl()}?api-version=3";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(int);
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<int>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(int);
			}
		}

		public HttpResponseMessage EndpointRaw(int index, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!int.TryParse(index.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter index does not parse into an int.");
			}

			var controller = "TestQuery";
			string url = $@"api/{controller}/endpoint/{index.EncodeForUrl()}?api-version=3";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async ValueTask<int> EndpointAsync(int index, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!int.TryParse(index.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter index does not parse into an int.");
			}

			var controller = "TestQuery";
			string url = $@"api/{controller}/endpoint/{index.EncodeForUrl()}?api-version=3";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(null, cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(int);
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<int>(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(int);
			}
		}

		public async ValueTask<HttpResponseMessage> EndpointRawAsync(int index, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!int.TryParse(index.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter index does not parse into an int.");
			}

			var controller = "TestQuery";
			string url = $@"api/{controller}/endpoint/{index.EncodeForUrl()}?api-version=3";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(null, cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}
	}
}

namespace TestWebApp.Clients.V3_0
{
	public interface ITestRouteClient : ITestWebAppClient
	{
		int Endpoint(int index, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		HttpResponseMessage EndpointRaw(int index, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<int> EndpointAsync(int index, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
		ValueTask<HttpResponseMessage> EndpointRawAsync(int index, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default);
	}

	internal class TestRouteClient : ITestRouteClient
	{
		protected readonly ITestWebAppClientWrapper Client;
		protected readonly IHttpOverride HttpOverride;
		protected readonly IHttpSerializer Serializer;
		protected readonly IHttpRequestModifier Modifier;
		public TestRouteClient(ITestWebAppClientWrapper param_client, Func<ITestWebAppClient, IHttpOverride> param_httpoverride, Func<ITestWebAppClient, IHttpSerializer> param_serializer, Func<ITestWebAppClient, IHttpRequestModifier> param_modifier)
		{
			Client = param_client;
			HttpOverride = param_httpoverride(this);
			Serializer = param_serializer(this);
			Modifier = param_modifier(this);
		}

		public int Endpoint(int index, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!int.TryParse(index.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter index does not parse into an int.");
			}

			var controller = "TestRoute";
			string url = $@"api/v3.0/{controller}/endpoint/{index.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(int);
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return Serializer.Deserialize<int>(response.Content).ConfigureAwait(false).GetAwaiter().GetResult();
			}
			else
			{
				return default(int);
			}
		}

		public HttpResponseMessage EndpointRaw(int index, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!int.TryParse(index.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter index does not parse into an int.");
			}

			var controller = "TestRoute";
			string url = $@"api/v3.0/{controller}/endpoint/{index.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(null, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false).GetAwaiter().GetResult();
			}

			return response;
		}

		public async ValueTask<int> EndpointAsync(int index, Action<HttpResponseMessage> ResponseCallback = null, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!int.TryParse(index.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter index does not parse into an int.");
			}

			var controller = "TestRoute";
			string url = $@"api/v3.0/{controller}/endpoint/{index.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(null, cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return default(int);
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			if (ResponseCallback != null && ResponseCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
			{
				throw new NotSupportedException("Async void action delegates for ResponseCallback are not supported.As they will run out of the scope of this call.");
			}

			if (ResponseCallback != null)
			{
				responseHandled = true;
				ResponseCallback.Invoke(response);
			}

			if (response.IsSuccessStatusCode)
			{
				return await Serializer.Deserialize<int>(response.Content).ConfigureAwait(false);
			}
			else
			{
				return default(int);
			}
		}

		public async ValueTask<HttpResponseMessage> EndpointRawAsync(int index, Action<FlurlHttpException> ExceptionCallback = null, IDictionary<String, Object> headers = null, IEnumerable<Cookie> cookies = null, TimeSpan? timeout = null, CancellationToken cancellationToken = default)
		{
			if (!int.TryParse(index.ToString(), out _))
			{
				throw new InvalidRouteException("Parameter index does not parse into an int.");
			}

			var controller = "TestRoute";
			string url = $@"api/v3.0/{controller}/endpoint/{index.EncodeForUrl()}";
			HttpResponseMessage response = null;
			response = await HttpOverride.GetResponseAsync(HttpMethod.Post, url, null, cancellationToken).ConfigureAwait(false);
			bool responseHandled = response != null;
			if (response == null)
			{
				try
				{
					response = await Client.ClientWrapper.Request(url).WithRequestModifiers(Modifier).WithCookies(cookies).WithHeaders(headers).WithTimeout(timeout ?? Client.Timeout).AllowAnyHttpStatus().PostAsync(null, cancellationToken).ConfigureAwait(false);
				}
				catch (FlurlHttpException fhex)
				{
					if (ExceptionCallback != null && ExceptionCallback.Method.IsDefined(typeof(AsyncStateMachineAttribute), true))
					{
						throw new NotSupportedException("Async void action delegates for ExceptionCallback are not supported.As they will run out of the scope of this call.");
					}

					if (ExceptionCallback != null)
					{
						responseHandled = true;
						ExceptionCallback?.Invoke(fhex);
					}
					else
					{
						throw fhex;
					}

					return null;
				}

				await HttpOverride.OnNonOverridedResponseAsync(HttpMethod.Post, url, null, response, cancellationToken).ConfigureAwait(false);
			}

			return response;
		}
	}
}

namespace TestWebApp.Hubs
{
	public class ChatHubConnectionBuilder : HubConnectionBuilder
	{
		private bool _hubConnectionBuilt;
		public ChatHubConnectionBuilder(Uri host, HttpTransportType? transports = null, Action<HttpConnectionOptions> configureHttpConnection = null): base()
		{
			//Remove default HubConnection to use custom one
			Services.Remove(Services.Where(x => x.ServiceType == typeof(HubConnection)).Single());
			Services.AddSingleton<ChatHubConnection>();
			Services.Configure<HttpConnectionOptions>(o =>
			{
				o.Url = new Uri(host, "Chat");
				if (transports != null)
				{
					o.Transports = transports.Value;
				}
			}

			);
			if (configureHttpConnection != null)
			{
				Services.Configure(configureHttpConnection);
			}

			Services.AddSingleton<IConnectionFactory, HttpConnectionFactory>();
		}

		public new ChatHubConnection Build()
		{
			// Build can only be used once
			if (_hubConnectionBuilt)
			{
				throw new InvalidOperationException("HubConnectionBuilder allows creation only of a single instance of HubConnection.");
			}

			_hubConnectionBuilt = true;
			// The service provider is disposed by the HubConnection
			var serviceProvider = Services.BuildServiceProvider();
			var connectionFactory = serviceProvider.GetService<IConnectionFactory>();
			if (connectionFactory == null)
			{
				throw new InvalidOperationException($"Cannot create {nameof(HubConnection)} instance.An {nameof(IConnectionFactory)} was not configured.");
			}

			return serviceProvider.GetService<ChatHubConnection>();
		}
	}

	public class ChatHubConnection : HubConnection
	{
		public ChatHubConnection(IConnectionFactory connectionFactory, IHubProtocol protocol, IServiceProvider serviceProvider, ILoggerFactory loggerFactory): base(connectionFactory, protocol, serviceProvider, loggerFactory)
		{
		}

		public ChatHubConnection(IConnectionFactory connectionFactory, IHubProtocol protocol, ILoggerFactory loggerFactory): base(connectionFactory, protocol, loggerFactory)
		{
		}

		public Task SendMessageAsync(string user, string message, CancellationToken cancellationToken = default)
		{
			return this.InvokeCoreAsync("SendMessage", new object[]{user, message}, cancellationToken);
		}

		public Task DtoMessageAsync(MyFancyDto dto, CancellationToken cancellationToken = default)
		{
			return this.InvokeCoreAsync("DtoMessage", new object[]{dto}, cancellationToken);
		}

		public Task<ChannelReader<int>> StreamCounterAsync(int count, int delay, CancellationToken cancellationToken = default)
		{
			return this.StreamAsChannelCoreAsync<int>("Counter", new object[]{count, delay}, cancellationToken);
		}

		public async Task<IEnumerable<int>> ReadCounterBlockingAsync(int count, int delay, CancellationToken cancellationToken = default)
		{
			var channel = await this.StreamAsChannelCoreAsync<int>("Counter", new object[]{count, delay}, cancellationToken);
			IList<int> items = new List<int>();
			while (await channel.WaitToReadAsync())
			{
				while (channel.TryRead(out var item))
				{
					items.Add(item);
				}
			}

			return items;
		}

		public IDisposable OnReceiveMessage(Action<string, string> action)
		{
			return this.On("ReceiveMessage", action);
		}

		public IDisposable OnReceiveMessage2(Action<MyFancyDto> action)
		{
			return this.On("ReceiveMessage2", action);
		}
	}

	namespace FancySuffix
	{
		public class NamespacedHubConnectionBuilder : HubConnectionBuilder
		{
			private bool _hubConnectionBuilt;
			public NamespacedHubConnectionBuilder(Uri host, HttpTransportType? transports = null, Action<HttpConnectionOptions> configureHttpConnection = null): base()
			{
				//Remove default HubConnection to use custom one
				Services.Remove(Services.Where(x => x.ServiceType == typeof(HubConnection)).Single());
				Services.AddSingleton<NamespacedHubConnection>();
				Services.Configure<HttpConnectionOptions>(o =>
				{
					o.Url = new Uri(host, "Test");
					if (transports != null)
					{
						o.Transports = transports.Value;
					}
				}

				);
				if (configureHttpConnection != null)
				{
					Services.Configure(configureHttpConnection);
				}

				Services.AddSingleton<IConnectionFactory, HttpConnectionFactory>();
			}

			public new NamespacedHubConnection Build()
			{
				// Build can only be used once
				if (_hubConnectionBuilt)
				{
					throw new InvalidOperationException("HubConnectionBuilder allows creation only of a single instance of HubConnection.");
				}

				_hubConnectionBuilt = true;
				// The service provider is disposed by the HubConnection
				var serviceProvider = Services.BuildServiceProvider();
				var connectionFactory = serviceProvider.GetService<IConnectionFactory>();
				if (connectionFactory == null)
				{
					throw new InvalidOperationException($"Cannot create {nameof(HubConnection)} instance.An {nameof(IConnectionFactory)} was not configured.");
				}

				return serviceProvider.GetService<NamespacedHubConnection>();
			}
		}

		public class NamespacedHubConnection : HubConnection
		{
			public NamespacedHubConnection(IConnectionFactory connectionFactory, IHubProtocol protocol, IServiceProvider serviceProvider, ILoggerFactory loggerFactory): base(connectionFactory, protocol, serviceProvider, loggerFactory)
			{
			}

			public NamespacedHubConnection(IConnectionFactory connectionFactory, IHubProtocol protocol, ILoggerFactory loggerFactory): base(connectionFactory, protocol, loggerFactory)
			{
			}

			public Task TestMessageAsync(CancellationToken cancellationToken = default)
			{
				return this.InvokeCoreAsync("TestMessage", null, cancellationToken);
			}

			public IDisposable OnTestMessage(Action<string> action)
			{
				return this.On("TestMessage", action);
			}
		}
	}
}